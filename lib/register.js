// Generated by kaoscript 0.9.0
require("kaoscript/register");
var {Helper, Type} = require("@kaoscript/runtime");
var {Compiler, extensions, getBinaryPath, getHashPath, isUpToDate} = require("./compiler.js")();
var fs = require("kaoscript/src/fs.js");
var path = require("path");
var registerExtension = require("../src/module.js").registerExtension;
function excludeFile(filename) {
	if(arguments.length < 1) {
		throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
	}
	if(filename === void 0 || filename === null) {
		throw new TypeError("'filename' is not nullable");
	}
	filename = path.relative(root, filename);
	for(let __ks_0 = 0, __ks_1 = excludes.length, exclude; __ks_0 < __ks_1; ++__ks_0) {
		exclude = excludes[__ks_0];
		if(filename.startsWith(exclude)) {
			return true;
		}
	}
	return false;
}
function loadFile(module, filename) {
	if(arguments.length < 2) {
		throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
	}
	if(module === void 0 || module === null) {
		throw new TypeError("'module' is not nullable");
	}
	if(filename === void 0 || filename === null) {
		throw new TypeError("'filename' is not nullable");
	}
	if(excludeFile(filename)) {
		return loadOriginalFile(module, filename);
	}
	else {
		return loadInstrumentedFile(module, filename);
	}
}
function loadInstrumentedFile(module, filename) {
	if(arguments.length < 2) {
		throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
	}
	if(module === void 0 || module === null) {
		throw new TypeError("'module' is not nullable");
	}
	if(filename === void 0 || filename === null) {
		throw new TypeError("'filename' is not nullable");
	}
	const compiler = new Compiler(filename, {
		register: false,
		target,
		excludeFile
	});
	compiler.instrument(coverageName);
	compiler.compile(fs.readFile(filename));
	compiler.writeFiles();
	const data = compiler.toSource();
	return module._compile(data, filename);
}
function loadOriginalFile(module, filename) {
	if(arguments.length < 2) {
		throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
	}
	if(module === void 0 || module === null) {
		throw new TypeError("'module' is not nullable");
	}
	if(filename === void 0 || filename === null) {
		throw new TypeError("'filename' is not nullable");
	}
	const source = fs.readFile(filename);
	if(fs.isFile(getBinaryPath(filename, target)) && fs.isFile(getHashPath(filename, target)) && isUpToDate(filename, target, source)) {
		return module._compile(fs.readFile(getBinaryPath(filename, target)), filename);
	}
	else {
		const compiler = new Compiler(filename, {
			register: false,
			target,
			excludeFile
		});
		compiler.compile(source);
		compiler.writeFiles();
		return module._compile(compiler.toSource(), filename);
	}
}
function findGlobalVariable() {
	const coverageVar = "$$cov_" + Date.now() + "$$";
	if(Type.isValue(global[coverageVar])) {
		return coverageVar;
	}
	else {
		const coverageVars = Helper.mapObject(global, function(key) {
			return key;
		}, function(key) {
			return key.startsWith("$$cov_");
		});
		return (coverageVars.length === 1) ? coverageVars[0] : null;
	}
}
function writeOnExit(file) {
	if(file === void 0 || file === null) {
		file = "coverage/coverage.json";
	}
	process.on("exit", function() {
		try {
			fs.writeFile(file, JSON.stringify(global.__ks_coverage, null, 2));
		}
		catch(error) {
			console.error("Failed to write coverage data", Type.isValue(error.stack) ? error.stack : error);
		}
	});
}
const coverageName = findGlobalVariable();
const excludes = ["test/", "node_modules/", ".git/"];
const root = process.cwd();
const target = (parseInt(/^v(\d+)\./.exec(process.version)[1]) >= 6) ? "ecma-v6" : "ecma-v5";
registerExtension(extensions.source, loadFile);
if(!Type.isValue(coverageName)) {
	writeOnExit(process.env.COFFEECOV_OUT);
}