// Generated by kaoscript 0.9.0
require("kaoscript/register");
var __ks__ = require("@kaoscript/runtime");
var Helper = __ks__.Helper, Type = __ks__.Type;
module.exports = function() {
	var __ks__ = require("kaoscript")();
	var Exception = __ks__.Exception, IOException = __ks__.IOException, NotImplementedException = __ks__.NotImplementedException, NotSupportedException = __ks__.NotSupportedException, ReferenceException = __ks__.ReferenceException, SyntaxException = __ks__.SyntaxException, TypeException = __ks__.TypeException, Module = __ks__.Module, Compiler = __ks__.Compiler, compileFile = __ks__.compileFile, getBinaryPath = __ks__.getBinaryPath, getHashPath = __ks__.getHashPath, getMetadataPath = __ks__.getMetadataPath, isUpToDate = __ks__.isUpToDate, extensions = __ks__.extensions, AssignmentOperatorKind = __ks__.AssignmentOperatorKind, BinaryOperatorKind = __ks__.BinaryOperatorKind, MacroElementKind = __ks__.MacroElementKind, ModifierKind = __ks__.ModifierKind, NodeKind = __ks__.NodeKind, ReificationKind = __ks__.ReificationKind, ScopeKind = __ks__.ScopeKind, UnaryOperatorKind = __ks__.UnaryOperatorKind, FragmentBuilder = __ks__.FragmentBuilder;
	function $block(init, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(init === void 0 || init === null) {
			throw new TypeError("'init' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(data.kind === NodeKind.Block) {
			data.statements = [].concat(init, $compile.statements(data.statements, coverage, coverageName, file, node));
			return data;
		}
		else {
			return {
				kind: NodeKind.Block,
				statements: [].concat(init, $compile.statements([data], coverage, coverageName, file, node))
			};
		}
	}
	function $body(data) {
		if(arguments.length < 1) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
		}
		if(data === void 0) {
			data = null;
		}
		if(data === null) {
			return {
				kind: NodeKind.Block,
				statements: []
			};
		}
		else if(data.kind === NodeKind.Block) {
			return data;
		}
		else {
			return {
				kind: NodeKind.Block,
				statements: [{
					kind: NodeKind.ReturnStatement,
					value: data,
					start: data.start,
					end: data.end
				}]
			};
		}
	}
	var $compile = {
		compile: function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue($statements[data.kind])) {
				return $statements[data.kind](data, coverage, coverageName, file, node);
			}
			else if(Type.isValue($expressions[data.kind])) {
				return $expressions[data.kind](data, coverage, coverageName, file, node);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + data.kind + "\"", file, data.start.line);
			}
		},
		expression: function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue($expressions[data.kind])) {
				return $expressions[data.kind](data, coverage, coverageName, file, node);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + data.kind + "\"", file, data.start.line);
			}
		},
		statements: function(statements, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(statements === void 0 || statements === null) {
				throw new TypeError("'statements' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			var result = [];
			for(var __ks_0 = 0, __ks_1 = statements.length, statement; __ks_0 < __ks_1; ++__ks_0) {
				statement = statements[__ks_0];
				var sid = coverage.statementMap.length + 1;
				coverage.statementMap.push({
					start: {
						line: statement.start.line,
						column: statement.start.column - 1
					},
					end: {
						line: statement.end.line,
						column: statement.end.column - 1
					}
				});
				result.push({
					kind: NodeKind.UnaryExpression,
					operator: {
						kind: UnaryOperatorKind.IncrementPostfix
					},
					argument: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.MemberExpression,
							object: {
								kind: NodeKind.MemberExpression,
								object: {
									kind: NodeKind.Identifier,
									name: coverageName
								},
								property: {
									kind: NodeKind.Literal,
									value: node.reducePath(file)
								},
								computed: true,
								nullable: false
							},
							property: {
								kind: NodeKind.Identifier,
								name: "s"
							},
							computed: false,
							nullable: false
						},
						property: {
							kind: NodeKind.NumericExpression,
							value: sid
						},
						computed: true,
						nullable: false
					},
					attributes: []
				});
				if(Type.isValue($statements[statement.kind])) {
					result.push($statements[statement.kind](statement, coverage, coverageName, file, node));
				}
				else if(Type.isValue($expressions[statement.kind])) {
					result.push($expressions[statement.kind](statement, coverage, coverageName, file, node));
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + statement.kind + "\"", file, statement.start.line);
				}
			}
			return result;
		}
	};
	function $constructor(members, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(members === void 0 || members === null) {
			throw new TypeError("'members' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var fid = coverage.fnMap.length + 1;
		coverage.fnMap.push({
			name: data.name.name,
			line: data.start.line,
			loc: {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.end.line,
					column: data.end.column - 1
				}
			}
		});
		var fields = {};
		for(var __ks_0 = 0, __ks_1 = members.length, member; __ks_0 < __ks_1; ++__ks_0) {
			member = members[__ks_0];
			if(member.kind === NodeKind.FieldDeclaration) {
				fields[member.name.name] = true;
				if(member.name.name[0] === "_") {
					fields[member.name.name.substr(1)] = true;
				}
			}
		}
		data.body = {
			kind: NodeKind.Block,
			statements: [{
				kind: NodeKind.CallExpression,
				scope: {
					kind: ScopeKind.This
				},
				callee: {
					kind: NodeKind.Identifier,
					name: "super",
					start: data.start,
					end: data.end
				},
				arguments: [],
				nullable: false
			}, {
				kind: NodeKind.UnaryExpression,
				operator: {
					kind: UnaryOperatorKind.IncrementPostfix
				},
				argument: {
					kind: NodeKind.MemberExpression,
					object: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.MemberExpression,
							object: {
								kind: NodeKind.Identifier,
								name: coverageName
							},
							property: {
								kind: NodeKind.Literal,
								value: node.reducePath(file)
							},
							computed: true,
							nullable: false
						},
						property: {
							kind: NodeKind.Identifier,
							name: "f"
						},
						computed: false,
						nullable: false
					},
					property: {
						kind: NodeKind.NumericExpression,
						value: fid
					},
					computed: true,
					nullable: false
				},
				attributes: []
			}]
		};
		return data;
	}
	var $expressions = {};
	$expressions[NodeKind.ArrayComprehension] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.ArrayExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.values = Helper.mapArray(data.values, function(value) {
			return $compile.expression(value, coverage, coverageName, file, node);
		});
		return data;
	};
	$expressions[NodeKind.ArrayRange] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.BinaryExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if((data.operator.kind === BinaryOperatorKind.And) || (data.operator.kind === BinaryOperatorKind.Or)) {
			var bid = coverage.branchMap.length + 1;
			coverage.branchMap.push({
				type: "binary-expr",
				line: data.start.line,
				locations: [{
					start: {
						line: data.left.start.line,
						column: data.left.start.column - 1
					},
					end: {
						line: data.left.end.line,
						column: data.left.end.column - 1
					}
				}, {
					start: {
						line: data.right.start.line,
						column: data.right.start.column - 1
					},
					end: {
						line: data.right.end.line,
						column: data.right.end.column - 1
					}
				}]
			});
			data.left = $sequence($increment.branch(bid, 0, coverageName, file, node), data.left, coverage, coverageName, file, node);
			data.right = $sequence($increment.branch(bid, 1, coverageName, file, node), data.right, coverage, coverageName, file, node);
		}
		else {
			data.left = $compile.expression(data.left, coverage, coverageName, file, node);
			data.right = $compile.expression(data.right, coverage, coverageName, file, node);
		}
		return data;
	};
	$expressions[NodeKind.CallExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.callee = $compile.expression(data.callee, coverage, coverageName, file, node);
		data.arguments = Helper.mapArray(data.arguments, function(argument) {
			return $compile.expression(argument, coverage, coverageName, file, node);
		});
		return data;
	};
	$expressions[NodeKind.CallMacroExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.ConditionalExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var bid = coverage.branchMap.length + 1;
		coverage.branchMap.push({
			type: "cond-expr",
			line: data.start.line,
			locations: [{
				start: {
					line: data.whenTrue.start.line,
					column: data.whenTrue.start.column - 1
				},
				end: {
					line: data.whenTrue.end.line,
					column: data.whenTrue.end.column - 1
				}
			}, {
				start: {
					line: data.whenFalse.start.line,
					column: data.whenFalse.start.column - 1
				},
				end: {
					line: data.whenFalse.end.line,
					column: data.whenFalse.end.column - 1
				}
			}]
		});
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, file, node), data.whenTrue, coverage, coverageName, file, node);
		data.whenFalse = $sequence($increment.branch(bid, 1, coverageName, file, node), data.whenFalse, coverage, coverageName, file, node);
		return data;
	};
	$expressions[NodeKind.CreateExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.class = $compile.expression(data.class, coverage, coverageName, file, node);
		data.arguments = Helper.mapArray(data.arguments, function(argument) {
			return $compile.expression(argument, coverage, coverageName, file, node);
		});
		return data;
	};
	$expressions[NodeKind.CurryExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.callee = $compile.expression(data.callee, coverage, coverageName, file, node);
		if(data.scope.kind === ScopeKind.Argument) {
			data.scope.value = $compile.expression(data.scope.value, coverage, coverageName, file, node);
		}
		data.arguments = Helper.mapArray(data.arguments, function(argument) {
			return $compile.expression(argument, coverage, coverageName, file, node);
		});
		return data;
	};
	$expressions[NodeKind.EnumExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.ExportNamedSpecifier] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.FunctionExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return $function(data, coverage, coverageName, file, node);
	};
	$expressions[NodeKind.IfExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var bid = coverage.branchMap.length + 1;
		if(Type.isValue(data.whenFalse)) {
			coverage.branchMap.push({
				type: "cond-expr",
				line: data.start.line,
				locations: [{
					start: {
						line: data.whenTrue.start.line,
						column: data.whenTrue.start.column - 1
					},
					end: {
						line: data.whenTrue.end.line,
						column: data.whenTrue.end.column - 1
					}
				}, {
					start: {
						line: data.whenFalse.start.line,
						column: data.whenFalse.start.column - 1
					},
					end: {
						line: data.whenFalse.end.line,
						column: data.whenFalse.end.column - 1
					}
				}]
			});
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, file, node), data.whenTrue, coverage, coverageName, file, node);
			data.whenFalse = $sequence($increment.branch(bid, 1, coverageName, file, node), data.whenFalse, coverage, coverageName, file, node);
		}
		else {
			coverage.branchMap.push({
				type: "cond-expr",
				line: data.start.line,
				locations: [{
					start: {
						line: data.start.line,
						column: data.start.column - 1
					},
					end: {
						line: data.start.line,
						column: data.start.column - 1
					}
				}, {
					start: {
						line: data.start.line,
						column: data.start.column - 1
					},
					end: {
						line: data.start.line,
						column: data.start.column - 1
					}
				}]
			});
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, file, node), data.whenTrue, coverage, coverageName, file, node);
		}
		return data;
	};
	$expressions[NodeKind.MemberExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.object = $compile.expression(data.object, coverage, coverageName, file, node);
		return data;
	};
	$expressions[NodeKind.NumericExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.Identifier] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.LambdaExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return $function(data, coverage, coverageName, file, node);
	};
	$expressions[NodeKind.Literal] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.ObjectExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var properties = data.properties;
		data.properties = [];
		for(var __ks_0 = 0, __ks_1 = properties.length, property; __ks_0 < __ks_1; ++__ks_0) {
			property = properties[__ks_0];
			data.properties.push($compile.expression(property, coverage, coverageName, file, node));
		}
		return data;
	};
	$expressions[NodeKind.ObjectMember] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.value = $compile.expression(data.value, coverage, coverageName, file, node);
		return data;
	};
	$expressions[NodeKind.PolyadicExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if((data.operator.kind === BinaryOperatorKind.And) || (data.operator.kind === BinaryOperatorKind.Or)) {
			var bid = coverage.branchMap.length + 1;
			var branch;
			coverage.branchMap.push(branch = {
				type: "binary-expr",
				line: data.start.line,
				locations: []
			});
			var operands = data.operands;
			data.operands = [];
			for(var index = 0, __ks_0 = operands.length, operand; index < __ks_0; ++index) {
				operand = operands[index];
				branch.locations.push({
					start: {
						line: operand.start.line,
						column: operand.start.column - 1
					},
					end: {
						line: operand.end.line,
						column: operand.end.column - 1
					}
				});
				data.operands.push($sequence($increment.branch(bid, index, coverageName, file, node), operand, coverage, coverageName, file, node));
			}
		}
		else {
			data.operands = Helper.mapArray(data.operands, function(operand) {
				return $compile.expression(operand, coverage, coverageName, file, node);
			});
		}
		return data;
	};
	$expressions[NodeKind.RegularExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.TemplateExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.elements = Helper.mapArray(data.elements, function(element) {
			return $compile.expression(element, coverage, coverageName, file, node);
		});
		return data;
	};
	$expressions[NodeKind.ThisExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.TypeReference] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$expressions[NodeKind.UnaryExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.argument = $compile.expression(data.argument, coverage, coverageName, file, node);
		return data;
	};
	$expressions[NodeKind.UnlessExpression] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var bid = coverage.branchMap.length + 1;
		coverage.branchMap.push({
			type: "cond-expr",
			line: data.start.line,
			locations: [{
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.start.line,
					column: data.start.column - 1
				}
			}, {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.start.line,
					column: data.start.column - 1
				}
			}]
		});
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.whenFalse = $sequence($increment.branch(bid, 0, coverageName, file, node), data.whenFalse, coverage, coverageName, file, node);
		return data;
	};
	function $function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var fid = coverage.fnMap.length + 1;
		coverage.fnMap.push({
			name: (Type.isValue(data.name) && Type.isValue(data.name.name)) ? data.name.name : ("(anonymous_" + fid + ")"),
			line: data.start.line,
			loc: {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.end.line,
					column: data.end.column - 1
				}
			}
		});
		data.body = $block({
			kind: NodeKind.UnaryExpression,
			operator: {
				kind: UnaryOperatorKind.IncrementPostfix
			},
			argument: {
				kind: NodeKind.MemberExpression,
				object: {
					kind: NodeKind.MemberExpression,
					object: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.Identifier,
							name: coverageName
						},
						property: {
							kind: NodeKind.Literal,
							value: node.reducePath(file)
						},
						computed: true,
						nullable: false
					},
					property: {
						kind: NodeKind.Identifier,
						name: "f"
					},
					computed: false,
					nullable: false
				},
				property: {
					kind: NodeKind.NumericExpression,
					value: fid
				},
				computed: true,
				nullable: false
			},
			attributes: []
		}, $body(data.body), coverage, coverageName, file, node);
		return data;
	}
	function $if(condition, whenTrue, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(condition === void 0 || condition === null) {
			throw new TypeError("'condition' is not nullable");
		}
		if(whenTrue === void 0 || whenTrue === null) {
			throw new TypeError("'whenTrue' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var data = {
			kind: NodeKind.IfStatement,
			condition: condition,
			start: condition.start,
			end: whenTrue.end
		};
		if(whenTrue.kind === NodeKind.Block) {
			data.whenTrue = whenTrue;
		}
		else {
			data.whenTrue = {
				kind: NodeKind.Block,
				statements: [whenTrue]
			};
		}
		return $statements[NodeKind.IfStatement](data, coverage, coverageName, file, node);
	}
	var $increment = {
		branch: function(bid, eid, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(bid === void 0 || bid === null) {
				throw new TypeError("'bid' is not nullable");
			}
			if(eid === void 0 || eid === null) {
				throw new TypeError("'eid' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return {
				kind: NodeKind.UnaryExpression,
				operator: {
					kind: UnaryOperatorKind.IncrementPostfix
				},
				argument: {
					kind: NodeKind.MemberExpression,
					object: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.MemberExpression,
							object: {
								kind: NodeKind.MemberExpression,
								object: {
									kind: NodeKind.Identifier,
									name: coverageName
								},
								property: {
									kind: NodeKind.Literal,
									value: node.reducePath(file)
								},
								computed: true,
								nullable: false
							},
							property: {
								kind: NodeKind.Identifier,
								name: "b"
							},
							computed: false,
							nullable: false
						},
						property: {
							kind: NodeKind.NumericExpression,
							value: bid
						},
						computed: true,
						nullable: false
					},
					property: {
						kind: NodeKind.NumericExpression,
						value: eid
					},
					computed: true,
					nullable: false
				},
				attributes: []
			};
		}
	};
	function $sequence(init, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(init === void 0 || init === null) {
			throw new TypeError("'init' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(data.kind === NodeKind.SequenceExpression) {
			var expressions = data.expressions;
			data.expressions = [init];
			for(var __ks_0 = 0, __ks_1 = expressions.length, expression; __ks_0 < __ks_1; ++__ks_0) {
				expression = expressions[__ks_0];
				data.expressions.push($compile.expression(expression, coverage, coverageName, file, node));
			}
			return data;
		}
		else {
			return {
				kind: NodeKind.SequenceExpression,
				expressions: [init, $compile.expression(data, coverage, coverageName, file, node)]
			};
		}
	}
	var $statements = {};
	$statements[NodeKind.BreakStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.ClassDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var members = data.members;
		data.members = [];
		for(var __ks_0 = 0, __ks_1 = members.length, member; __ks_0 < __ks_1; ++__ks_0) {
			member = members[__ks_0];
			var __ks_2 = member.kind;
			if(__ks_2 === NodeKind.FieldDeclaration) {
				if(Type.isValue(member.defaultValue)) {
					member.defaultValue = $compile.expression(member.defaultValue, coverage, coverageName, file, node);
				}
				data.members.push(member);
			}
			else if(__ks_2 === NodeKind.MethodDeclaration) {
				if(Type.isValue(data.extends) && (member.name.name === "constructor") && !Type.isValue(member.body)) {
					data.members.push($constructor(members, member, coverage, coverageName, file, node));
				}
				else {
					data.members.push($statements[NodeKind.FunctionDeclaration](member, coverage, coverageName, file, node));
				}
			}
			else if(__ks_2 === NodeKind.MacroDeclaration) {
				data.members.push(member);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + member.kind + "\"", file, member.start.line);
			}
		}
		return data;
	};
	$statements[NodeKind.ContinueStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.DestroyStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.DoUntilStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.DoWhileStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.EnumDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.ExportDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.declarations = Helper.mapArray(data.declarations, function(declaration) {
			return $compile.compile(declaration, coverage, coverageName, file, node);
		});
		return data;
	};
	$statements[NodeKind.ExportDeclarationSpecifier] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.declaration = $compile.compile(data.declaration, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.ExternDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.ExternOrRequireDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.ForFromStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.from = $compile.expression(data.from, coverage, coverageName, file, node);
		if(Type.isValue(data.til)) {
			data.til = $compile.expression(data.til, coverage, coverageName, file, node);
		}
		else {
			data.to = $compile.expression(data.to, coverage, coverageName, file, node);
		}
		if(Type.isValue(data.by)) {
			data.by = $compile.expression(data.by, coverage, coverageName, file, node);
		}
		if(Type.isValue(data.when)) {
			data.body = $if(data.when, data.body, coverage, coverageName, file, node);
			delete data.when;
		}
		else {
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		}
		return data;
	};
	$statements[NodeKind.ForInStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(Type.isValue(data.when)) {
			data.body = $if(data.when, data.body, coverage, coverageName, file, node);
			delete data.when;
		}
		else {
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		}
		return data;
	};
	$statements[NodeKind.ForOfStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(Type.isValue(data.when)) {
			data.body = $if(data.when, data.body, coverage, coverageName, file, node);
			delete data.when;
		}
		else {
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		}
		return data;
	};
	$statements[NodeKind.FunctionDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return $function(data, coverage, coverageName, file, node);
	};
	$statements[NodeKind.IfStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var bid = coverage.branchMap.length + 1;
		var loc = {
			start: {
				line: data.start.line,
				column: data.start.column - 1
			},
			end: {
				line: data.start.line,
				column: data.start.column - 1
			}
		};
		coverage.branchMap.push({
			type: "if",
			line: data.start.line,
			locations: [loc, loc]
		});
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.whenTrue = $block($increment.branch(bid, 0, coverageName, file, node), data.whenTrue, coverage, coverageName, file, node);
		if(Type.isValue(data.whenFalse)) {
			data.whenFalse = $block($increment.branch(bid, 1, coverageName, file, node), data.whenFalse, coverage, coverageName, file, node);
		}
		return data;
	};
	$statements[NodeKind.ImplementDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var properties = data.properties;
		data.properties = [];
		for(var __ks_0 = 0, __ks_1 = properties.length, property; __ks_0 < __ks_1; ++__ks_0) {
			property = properties[__ks_0];
			var __ks_2 = property.kind;
			if(__ks_2 === NodeKind.FieldDeclaration) {
				if(Type.isValue(property.defaultValue)) {
					property.defaultValue = $compile.expression(property.defaultValue, coverage, coverageName, file, node);
				}
				data.properties.push(property);
			}
			else if(__ks_2 === NodeKind.MethodDeclaration) {
				data.properties.push($statements[NodeKind.FunctionDeclaration](property, coverage, coverageName, file, node));
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + property.kind + "\"", file, property.start.line);
			}
		}
		return data;
	};
	$statements[NodeKind.ImportDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.IncludeDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.MacroDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.NamespaceDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.statements = $compile.statements(data.statements, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.RequireDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.RequireOrExternDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.RequireOrImportDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.ReturnStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(Type.isValue(data.value)) {
			data.value = $compile.expression(data.value, coverage, coverageName, file, node);
		}
		return data;
	};
	$statements[NodeKind.SwitchStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var bid = coverage.branchMap.length + 1;
		var branch = {
			type: "switch",
			line: data.start.line,
			locations: []
		};
		coverage.branchMap.push(branch);
		data.expression = $compile.expression(data.expression, coverage, coverageName, file, node);
		for(var index = 0, __ks_0 = data.clauses.length, clause; index < __ks_0; ++index) {
			clause = data.clauses[index];
			clause.body = $block($increment.branch(bid, index, coverageName, file, node), clause.body, coverage, coverageName, file, node);
			branch.locations.push({
				start: {
					line: clause.start.line,
					column: clause.start.column - 1
				},
				end: {
					line: clause.end.line,
					column: clause.end.column - 1
				}
			});
		}
		return data;
	};
	$statements[NodeKind.ThrowStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.value = $compile.expression(data.value, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.TryStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.TypeAliasDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		return data;
	};
	$statements[NodeKind.UnlessStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		var bid = coverage.branchMap.length + 1;
		var loc = {
			start: {
				line: data.start.line,
				column: data.start.column - 1
			},
			end: {
				line: data.start.line,
				column: data.start.column - 1
			}
		};
		coverage.branchMap.push({
			type: "if",
			line: data.start.line,
			locations: [loc, loc]
		});
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.whenFalse = $block($increment.branch(bid, 0, coverageName, file, node), data.whenFalse, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.UntilStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		return data;
	};
	$statements[NodeKind.VariableDeclaration] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(Type.isValue(data.init)) {
			data.init = $compile.expression(data.init, coverage, coverageName, file, node);
		}
		return data;
	};
	$statements[NodeKind.WhileStatement] = function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
		data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
		return data;
	};
	var CoverageCompiler = Helper.class({
		$name: "CoverageCompiler",
		$extends: Compiler,
		__ks_init_1: function() {
			this._instrument = false;
		},
		__ks_init: function() {
			Compiler.prototype.__ks_init.call(this);
			CoverageCompiler.prototype.__ks_init_1.call(this);
		},
		__ks_cons: function(args) {
			Compiler.prototype.__ks_cons.call(this, args);
		},
		__ks_func_instrument_0: function(coverageName) {
			if(coverageName === void 0 || coverageName === null) {
				coverageName = "__ks_coverage";
			}
			this._coverageName = coverageName;
			this._instrument = true;
			return this;
		},
		instrument: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return CoverageCompiler.prototype.__ks_func_instrument_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_compile_0: function(data) {
			if(data === void 0) {
				data = null;
			}
			if(this._instrument) {
				this._module = new CoverageModule(Type.isValue(data) ? data : this.readFile(), this._coverageName, this, this._file);
			}
			else {
				this._module = new Module(Type.isValue(data) ? data : this.readFile(), this, this._file);
			}
			this._module.compile();
			this._fragments = this._module.toFragments();
			return this;
		},
		compile: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return CoverageCompiler.prototype.__ks_func_compile_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		}
	});
	var CoverageModule = Helper.class({
		$name: "CoverageModule",
		$extends: Module,
		__ks_init_1: function() {
			this._addCoverageVariable = true;
			this._coverages = [];
			this.reducePath = function(path) {
				if(arguments.length < 1) {
					throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
				}
				if(path === void 0 || path === null) {
					throw new TypeError("'path' is not nullable");
				}
				return path;
			};
		},
		__ks_init: function() {
			Module.prototype.__ks_init.call(this);
			CoverageModule.prototype.__ks_init_1.call(this);
		},
		__ks_cons_0: function(data, coverageName, compiler, file) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(compiler === void 0 || compiler === null) {
				throw new TypeError("'compiler' is not nullable");
			}
			else if(!Type.is(compiler, Compiler)) {
				throw new TypeError("'compiler' is not of type 'Compiler'");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			this._coverageName = coverageName;
			Module.prototype.__ks_cons.call(this, [data, compiler, file]);
		},
		__ks_cons: function(args) {
			if(args.length === 4) {
				CoverageModule.prototype.__ks_cons_0.apply(this, args);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		},
		__ks_func_parse_0: function(data, file) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(Type.isFunction(this._compiler._options.reducePath)) {
				this.reducePath = this._compiler._options.reducePath;
			}
			var coverage;
			this._coverages.push(coverage = {
				path: this.reducePath(file),
				statementMap: [],
				branchMap: [],
				fnMap: []
			});
			data = Module.prototype.parse.apply(this, [data, file]);
			data.body = $compile.statements(data.body, coverage, this._coverageName, file, this);
			if(this._addCoverageVariable) {
				data.body.unshift({
					kind: NodeKind.ExternDeclaration,
					declarations: [{
						kind: NodeKind.VariableDeclarator,
						name: {
							kind: NodeKind.Identifier,
							name: this._coverageName
						}
					}],
					attributes: []
				});
				this._addCoverageVariable = false;
			}
			return data;
		},
		parse: function() {
			if(arguments.length === 2) {
				return CoverageModule.prototype.__ks_func_parse_0.apply(this, arguments);
			}
			return Module.prototype.parse.apply(this, arguments);
		},
		__ks_func_toFragments_0: function() {
			var header = new FragmentBuilder(0);
			header.line("var " + this._coverageName + " = (function(_export) {\n\treturn typeof _export." + this._coverageName + " === 'undefined' ? _export." + this._coverageName + " = {} : _export." + this._coverageName + ";\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this)");
			for(var __ks_0 = 0, __ks_1 = this._coverages.length, coverage; __ks_0 < __ks_1; ++__ks_0) {
				coverage = this._coverages[__ks_0];
				this.toCoverageFragments(header, coverage);
			}
			return header.toArray().concat(Module.prototype.toFragments.apply(this, []));
		},
		toFragments: function() {
			if(arguments.length === 0) {
				return CoverageModule.prototype.__ks_func_toFragments_0.apply(this);
			}
			return Module.prototype.toFragments.apply(this, arguments);
		},
		__ks_func_toCoverageFragments_0: function(fragments, coverage) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(fragments === void 0 || fragments === null) {
				throw new TypeError("'fragments' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			var line = fragments.newLine();
			line.code("if(!" + this._coverageName + "[\"" + coverage.path + "\"]) {\n");
			line.code("\t" + this._coverageName + "[\"" + coverage.path + "\"] = {");
			line.code("\"path\":\"" + coverage.path + "\",");
			line.code("\"s\":{");
			for(var i = 1, __ks_0 = coverage.statementMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":0");
			}
			line.code("},");
			line.code("\"b\":{");
			for(var i = 1, __ks_0 = coverage.branchMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":[");
				for(var j = 0, __ks_1 = coverage.branchMap[i - 1].locations.length; j < __ks_1; ++j) {
					if(j !== 0) {
						line.code(",");
					}
					line.code("0");
				}
				line.code("]");
			}
			line.code("},");
			line.code("\"f\":{");
			for(var i = 1, __ks_0 = coverage.fnMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":0");
			}
			line.code("},");
			line.code("\"statementMap\":{");
			for(var i = 0, __ks_0 = coverage.statementMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.statementMap[i]));
			}
			line.code("},");
			line.code("\"branchMap\":{");
			for(var i = 0, __ks_0 = coverage.branchMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.branchMap[i]));
			}
			line.code("},");
			line.code("\"fnMap\":{");
			for(var i = 0, __ks_0 = coverage.fnMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.fnMap[i]));
			}
			line.code("}");
			line.code("};\n");
			line.code("}");
			line.done();
		},
		toCoverageFragments: function() {
			if(arguments.length === 2) {
				return CoverageModule.prototype.__ks_func_toCoverageFragments_0.apply(this, arguments);
			}
			else if(Module.prototype.toCoverageFragments) {
				return Module.prototype.toCoverageFragments.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		}
	});
	return {
		Compiler: CoverageCompiler,
		extensions: extensions,
		getBinaryPath: getBinaryPath,
		getHashPath: getHashPath,
		isUpToDate: isUpToDate
	};
};