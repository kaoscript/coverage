// Generated by kaoscript 0.9.1
require("kaoscript/register");
var {Dictionary, Helper, Operator, Type} = require("@kaoscript/runtime");
module.exports = function() {
	var {Exception, IOException, NotImplementedException, NotSupportedException, ReferenceException, SyntaxException, TypeException, Module, Compiler, compileFile, getBinaryPath, getHashPath, getMetadataPath, isUpToDate, extensions, AssignmentOperatorKind, BinaryOperatorKind, MacroElementKind, ModifierKind, NodeKind, ReificationKind, ScopeKind, UnaryOperatorKind, FragmentBuilder} = require("kaoscript")();
	function $block(init, data, coverage, coverageName, location, file, node) {
		if(arguments.length < 7) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 7)");
		}
		if(init === void 0 || init === null) {
			throw new TypeError("'init' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(location === void 0 || location === null) {
			throw new TypeError("'location' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(Helper.valueOf(data.kind) === NodeKind.Block.value) {
			data.statements = [].concat($location(init, location), $compile.statements(data.statements, coverage, coverageName, file, node));
			return data;
		}
		else {
			return $location((() => {
				const d = new Dictionary();
				d.kind = NodeKind.Block;
				d.statements = [].concat($location(init, location), $compile.statements([data], coverage, coverageName, file, node));
				return d;
			})(), location);
		}
	}
	function $body(data, location) {
		if(arguments.length < 2) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(data === void 0) {
			data = null;
		}
		if(location === void 0 || location === null) {
			throw new TypeError("'location' is not nullable");
		}
		if(data === null) {
			return $location((() => {
				const d = new Dictionary();
				d.kind = NodeKind.Block;
				d.statements = [];
				return d;
			})(), location);
		}
		else if(Helper.valueOf(data.kind) === NodeKind.Block.value) {
			return data;
		}
		else {
			return $location((() => {
				const d = new Dictionary();
				d.kind = NodeKind.Block;
				d.statements = [(() => {
					const d = new Dictionary();
					d.kind = NodeKind.ReturnStatement;
					d.value = data;
					d.start = data.start;
					d.end = data.end;
					return d;
				})()];
				return d;
			})(), location);
		}
	}
	const $compile = (() => {
		const d = new Dictionary();
		d.compile = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue($statements[data.kind])) {
				return $statements[data.kind](data, coverage, coverageName, file, node);
			}
			else if(Type.isValue($expressions[data.kind])) {
				return $expressions[data.kind](data, coverage, coverageName, file, node);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + data.kind + "\"", file, data.start.line);
			}
		};
		d.expression = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue($expressions[data.kind])) {
				return $expressions[data.kind](data, coverage, coverageName, file, node);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + data.kind + "\"", file, data.start.line);
			}
		};
		d.statements = function(statements, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(statements === void 0 || statements === null) {
				throw new TypeError("'statements' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			const result = [];
			for(let __ks_0 = 0, __ks_1 = statements.length, statement; __ks_0 < __ks_1; ++__ks_0) {
				statement = statements[__ks_0];
				let sid = Operator.addOrConcat(coverage.statementMap.length, 1);
				coverage.statementMap.push((() => {
					const d = new Dictionary();
					d.start = (() => {
						const d = new Dictionary();
						d.line = statement.start.line;
						d.column = Operator.subtraction(statement.start.column, 1);
						return d;
					})();
					d.end = (() => {
						const d = new Dictionary();
						d.line = statement.end.line;
						d.column = Operator.subtraction(statement.end.column, 1);
						return d;
					})();
					return d;
				})());
				result.push($location((() => {
					const d = new Dictionary();
					d.kind = NodeKind.UnaryExpression;
					d.operator = (() => {
						const d = new Dictionary();
						d.kind = UnaryOperatorKind.IncrementPostfix;
						return d;
					})();
					d.argument = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.MemberExpression;
						d.modifiers = [(() => {
							const d = new Dictionary();
							d.kind = ModifierKind.Computed;
							return d;
						})()];
						d.object = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.MemberExpression;
							d.modifiers = [];
							d.object = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.MemberExpression;
								d.modifiers = [(() => {
									const d = new Dictionary();
									d.kind = ModifierKind.Computed;
									return d;
								})()];
								d.object = (() => {
									const d = new Dictionary();
									d.kind = NodeKind.Identifier;
									d.name = coverageName;
									return d;
								})();
								d.property = (() => {
									const d = new Dictionary();
									d.kind = NodeKind.Literal;
									d.value = node.reducePath(file);
									return d;
								})();
								return d;
							})();
							d.property = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.Identifier;
								d.name = "s";
								return d;
							})();
							return d;
						})();
						d.property = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.NumericExpression;
							d.value = sid;
							return d;
						})();
						return d;
					})();
					d.attributes = [];
					return d;
				})(), statement));
				if(Type.isValue($statements[statement.kind])) {
					result.push($statements[statement.kind](statement, coverage, coverageName, file, node));
				}
				else if(Type.isValue($expressions[statement.kind])) {
					result.push($expressions[statement.kind](statement, coverage, coverageName, file, node));
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + statement.kind + "\"", file, statement.start.line);
				}
			}
			return result;
		};
		return d;
	})();
	function $constructor(members, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(members === void 0 || members === null) {
			throw new TypeError("'members' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		let fid = Operator.addOrConcat(coverage.fnMap.length, 1);
		coverage.fnMap.push((() => {
			const d = new Dictionary();
			d.name = data.name.name;
			d.line = data.start.line;
			d.loc = (() => {
				const d = new Dictionary();
				d.start = (() => {
					const d = new Dictionary();
					d.line = data.start.line;
					d.column = Operator.subtraction(data.start.column, 1);
					return d;
				})();
				d.end = (() => {
					const d = new Dictionary();
					d.line = data.end.line;
					d.column = Operator.subtraction(data.end.column, 1);
					return d;
				})();
				return d;
			})();
			return d;
		})());
		const fields = new Dictionary();
		for(let __ks_0 = 0, __ks_1 = members.length, member; __ks_0 < __ks_1; ++__ks_0) {
			member = members[__ks_0];
			if(Helper.valueOf(member.kind) === NodeKind.FieldDeclaration.value) {
				fields[member.name.name] = true;
				if(member.name.name[0] === "_") {
					fields[member.name.name.substr(1)] = true;
				}
			}
		}
		data.body = $location((() => {
			const d = new Dictionary();
			d.kind = NodeKind.Block;
			d.statements = [$location((() => {
				const d = new Dictionary();
				d.kind = NodeKind.CallExpression;
				d.modifiers = [];
				d.scope = (() => {
					const d = new Dictionary();
					d.kind = ScopeKind.This;
					return d;
				})();
				d.callee = (() => {
					const d = new Dictionary();
					d.kind = NodeKind.Identifier;
					d.name = "super";
					d.start = data.start;
					d.end = data.end;
					return d;
				})();
				d.arguments = [];
				return d;
			})(), data), $location((() => {
				const d = new Dictionary();
				d.kind = NodeKind.UnaryExpression;
				d.operator = (() => {
					const d = new Dictionary();
					d.kind = UnaryOperatorKind.IncrementPostfix;
					return d;
				})();
				d.argument = (() => {
					const d = new Dictionary();
					d.kind = NodeKind.MemberExpression;
					d.modifiers = [(() => {
						const d = new Dictionary();
						d.kind = ModifierKind.Computed;
						return d;
					})()];
					d.object = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.MemberExpression;
						d.modifiers = [];
						d.object = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.MemberExpression;
							d.modifiers = [(() => {
								const d = new Dictionary();
								d.kind = ModifierKind.Computed;
								return d;
							})()];
							d.object = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.Identifier;
								d.name = coverageName;
								return d;
							})();
							d.property = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.Literal;
								d.value = node.reducePath(file);
								return d;
							})();
							return d;
						})();
						d.property = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.Identifier;
							d.name = "f";
							return d;
						})();
						return d;
					})();
					d.property = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.NumericExpression;
						d.value = fid;
						return d;
					})();
					return d;
				})();
				d.attributes = [];
				return d;
			})(), data)];
			return d;
		})(), data);
		return data;
	}
	const $expressions = (() => {
		const d = new Dictionary();
		d[NodeKind.ArrayComprehension] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ArrayExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.values = Helper.mapArray(data.values, function(value) {
				return $compile.expression(value, coverage, coverageName, file, node);
			});
			return data;
		};
		d[NodeKind.ArrayRange] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.AwaitExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.BinaryExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if((Helper.valueOf(data.operator.kind) === BinaryOperatorKind.And.value) || (Helper.valueOf(data.operator.kind) === BinaryOperatorKind.Or.value)) {
				let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
				coverage.branchMap.push((() => {
					const d = new Dictionary();
					d.type = "binary-expr";
					d.line = data.start.line;
					d.locations = [(() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = data.left.start.line;
							d.column = Operator.subtraction(data.left.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = data.left.end.line;
							d.column = Operator.subtraction(data.left.end.column, 1);
							return d;
						})();
						return d;
					})(), (() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = data.right.start.line;
							d.column = Operator.subtraction(data.right.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = data.right.end.line;
							d.column = Operator.subtraction(data.right.end.column, 1);
							return d;
						})();
						return d;
					})()];
					return d;
				})());
				data.left = $sequence($increment.branch(bid, 0, coverageName, data.left, file, node), data.left, coverage, coverageName, file, node);
				data.right = $sequence($increment.branch(bid, 1, coverageName, data.right, file, node), data.right, coverage, coverageName, file, node);
			}
			else if(Helper.valueOf(data.operator.kind) === BinaryOperatorKind.Assignment.value) {
				data.right = $compile.expression(data.right, coverage, coverageName, file, node);
			}
			else {
				data.left = $compile.expression(data.left, coverage, coverageName, file, node);
				data.right = $compile.expression(data.right, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.CallExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.callee = $compile.expression(data.callee, coverage, coverageName, file, node);
			data.arguments = Helper.mapArray(data.arguments, function(argument) {
				return $compile.expression(argument, coverage, coverageName, file, node);
			});
			return data;
		};
		d[NodeKind.CallMacroExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ComparisonExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ConditionalExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
			coverage.branchMap.push((() => {
				const d = new Dictionary();
				d.type = "cond-expr";
				d.line = data.start.line;
				d.locations = [(() => {
					const d = new Dictionary();
					d.start = (() => {
						const d = new Dictionary();
						d.line = data.whenTrue.start.line;
						d.column = Operator.subtraction(data.whenTrue.start.column, 1);
						return d;
					})();
					d.end = (() => {
						const d = new Dictionary();
						d.line = data.whenTrue.end.line;
						d.column = Operator.subtraction(data.whenTrue.end.column, 1);
						return d;
					})();
					return d;
				})(), (() => {
					const d = new Dictionary();
					d.start = (() => {
						const d = new Dictionary();
						d.line = data.whenFalse.start.line;
						d.column = Operator.subtraction(data.whenFalse.start.column, 1);
						return d;
					})();
					d.end = (() => {
						const d = new Dictionary();
						d.line = data.whenFalse.end.line;
						d.column = Operator.subtraction(data.whenFalse.end.column, 1);
						return d;
					})();
					return d;
				})()];
				return d;
			})());
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, file, node);
			data.whenFalse = $sequence($increment.branch(bid, 1, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.CreateExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.class = $compile.expression(data.class, coverage, coverageName, file, node);
			data.arguments = Helper.mapArray(data.arguments, function(argument) {
				return $compile.expression(argument, coverage, coverageName, file, node);
			});
			return data;
		};
		d[NodeKind.CurryExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.callee = $compile.expression(data.callee, coverage, coverageName, file, node);
			if(Helper.valueOf(data.scope.kind) === ScopeKind.Argument.value) {
				data.scope.value = $compile.expression(data.scope.value, coverage, coverageName, file, node);
			}
			data.arguments = Helper.mapArray(data.arguments, function(argument) {
				return $compile.expression(argument, coverage, coverageName, file, node);
			});
			return data;
		};
		d[NodeKind.EnumExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ExportNamedSpecifier] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.FunctionExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $function(data, coverage, coverageName, file, node);
		};
		d[NodeKind.IfExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
			if(Type.isValue(data.whenFalse)) {
				coverage.branchMap.push((() => {
					const d = new Dictionary();
					d.type = "cond-expr";
					d.line = data.start.line;
					d.locations = [(() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = data.whenTrue.start.line;
							d.column = Operator.subtraction(data.whenTrue.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = data.whenTrue.end.line;
							d.column = Operator.subtraction(data.whenTrue.end.column, 1);
							return d;
						})();
						return d;
					})(), (() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = data.whenFalse.start.line;
							d.column = Operator.subtraction(data.whenFalse.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = data.whenFalse.end.line;
							d.column = Operator.subtraction(data.whenFalse.end.column, 1);
							return d;
						})();
						return d;
					})()];
					return d;
				})());
				data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
				data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, file, node);
				data.whenFalse = $sequence($increment.branch(bid, 1, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, file, node);
			}
			else {
				coverage.branchMap.push((() => {
					const d = new Dictionary();
					d.type = "cond-expr";
					d.line = data.start.line;
					d.locations = [(() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = data.start.line;
							d.column = Operator.subtraction(data.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = data.start.line;
							d.column = Operator.subtraction(data.start.column, 1);
							return d;
						})();
						return d;
					})(), (() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = data.start.line;
							d.column = Operator.subtraction(data.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = data.start.line;
							d.column = Operator.subtraction(data.start.column, 1);
							return d;
						})();
						return d;
					})()];
					return d;
				})());
				data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
				data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.MemberExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.object = $compile.expression(data.object, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.NumericExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.Identifier] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.LambdaExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $function(data, coverage, coverageName, file, node);
		};
		d[NodeKind.Literal] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ObjectExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let properties = data.properties;
			data.properties = [];
			for(let __ks_0 = 0, __ks_1 = properties.length, property; __ks_0 < __ks_1; ++__ks_0) {
				property = properties[__ks_0];
				data.properties.push($compile.expression(property, coverage, coverageName, file, node));
			}
			return data;
		};
		d[NodeKind.ObjectMember] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.value = $compile.expression(data.value, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.PolyadicExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if((Helper.valueOf(data.operator.kind) === BinaryOperatorKind.And.value) || (Helper.valueOf(data.operator.kind) === BinaryOperatorKind.Or.value)) {
				let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
				let branch;
				coverage.branchMap.push(branch = (() => {
					const d = new Dictionary();
					d.type = "binary-expr";
					d.line = data.start.line;
					d.locations = [];
					return d;
				})());
				let operands = data.operands;
				data.operands = [];
				for(let index = 0, __ks_0 = operands.length, operand; index < __ks_0; ++index) {
					operand = operands[index];
					branch.locations.push((() => {
						const d = new Dictionary();
						d.start = (() => {
							const d = new Dictionary();
							d.line = operand.start.line;
							d.column = Operator.subtraction(operand.start.column, 1);
							return d;
						})();
						d.end = (() => {
							const d = new Dictionary();
							d.line = operand.end.line;
							d.column = Operator.subtraction(operand.end.column, 1);
							return d;
						})();
						return d;
					})());
					data.operands.push($sequence($increment.branch(bid, index, coverageName, operand, file, node), operand, coverage, coverageName, file, node));
				}
			}
			else {
				data.operands = Helper.mapArray(data.operands, function(operand) {
					return $compile.expression(operand, coverage, coverageName, file, node);
				});
			}
			return data;
		};
		d[NodeKind.RegularExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ShorthandProperty] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.TemplateExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.elements = Helper.mapArray(data.elements, function(element) {
				return $compile.expression(element, coverage, coverageName, file, node);
			});
			return data;
		};
		d[NodeKind.ThisExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.TypeReference] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.UnaryExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.argument = $compile.expression(data.argument, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.UnlessExpression] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
			coverage.branchMap.push((() => {
				const d = new Dictionary();
				d.type = "cond-expr";
				d.line = data.start.line;
				d.locations = [(() => {
					const d = new Dictionary();
					d.start = (() => {
						const d = new Dictionary();
						d.line = data.start.line;
						d.column = Operator.subtraction(data.start.column, 1);
						return d;
					})();
					d.end = (() => {
						const d = new Dictionary();
						d.line = data.start.line;
						d.column = Operator.subtraction(data.start.column, 1);
						return d;
					})();
					return d;
				})(), (() => {
					const d = new Dictionary();
					d.start = (() => {
						const d = new Dictionary();
						d.line = data.start.line;
						d.column = Operator.subtraction(data.start.column, 1);
						return d;
					})();
					d.end = (() => {
						const d = new Dictionary();
						d.line = data.start.line;
						d.column = Operator.subtraction(data.start.column, 1);
						return d;
					})();
					return d;
				})()];
				return d;
			})());
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenFalse = $sequence($increment.branch(bid, 0, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.VariableDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.init = $compile.expression(data.init, coverage, coverageName, file, node);
			return data;
		};
		return d;
	})();
	function $function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		let fid = Operator.addOrConcat(coverage.fnMap.length, 1);
		coverage.fnMap.push((() => {
			const d = new Dictionary();
			d.name = (Type.isValue(data.name) && Type.isValue(data.name.name)) ? data.name.name : "(anonymous_" + fid + ")";
			d.line = data.start.line;
			d.loc = (() => {
				const d = new Dictionary();
				d.start = (() => {
					const d = new Dictionary();
					d.line = data.start.line;
					d.column = Operator.subtraction(data.start.column, 1);
					return d;
				})();
				d.end = (() => {
					const d = new Dictionary();
					d.line = data.end.line;
					d.column = Operator.subtraction(data.end.column, 1);
					return d;
				})();
				return d;
			})();
			return d;
		})());
		data.body = $block((() => {
			const d = new Dictionary();
			d.kind = NodeKind.UnaryExpression;
			d.operator = (() => {
				const d = new Dictionary();
				d.kind = UnaryOperatorKind.IncrementPostfix;
				return d;
			})();
			d.argument = (() => {
				const d = new Dictionary();
				d.kind = NodeKind.MemberExpression;
				d.modifiers = [(() => {
					const d = new Dictionary();
					d.kind = ModifierKind.Computed;
					return d;
				})()];
				d.object = (() => {
					const d = new Dictionary();
					d.kind = NodeKind.MemberExpression;
					d.modifiers = [];
					d.object = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.MemberExpression;
						d.modifiers = [(() => {
							const d = new Dictionary();
							d.kind = ModifierKind.Computed;
							return d;
						})()];
						d.object = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.Identifier;
							d.name = coverageName;
							return d;
						})();
						d.property = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.Literal;
							d.value = node.reducePath(file);
							return d;
						})();
						return d;
					})();
					d.property = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.Identifier;
						d.name = "f";
						return d;
					})();
					return d;
				})();
				d.property = (() => {
					const d = new Dictionary();
					d.kind = NodeKind.NumericExpression;
					d.value = fid;
					return d;
				})();
				return d;
			})();
			d.attributes = [];
			return d;
		})(), $body(data.body, data), coverage, coverageName, data, file, node);
		return data;
	}
	function $if(condition, whenTrue, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(condition === void 0 || condition === null) {
			throw new TypeError("'condition' is not nullable");
		}
		if(whenTrue === void 0 || whenTrue === null) {
			throw new TypeError("'whenTrue' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		let data = (() => {
			const d = new Dictionary();
			d.kind = NodeKind.IfStatement;
			d.condition = condition;
			d.start = condition.start;
			d.end = whenTrue.end;
			return d;
		})();
		if(Helper.valueOf(whenTrue.kind) === NodeKind.Block.value) {
			data.whenTrue = whenTrue;
		}
		else {
			data.whenTrue = (() => {
				const d = new Dictionary();
				d.kind = NodeKind.Block;
				d.statements = [whenTrue];
				return d;
			})();
		}
		return $statements[NodeKind.IfStatement](data, coverage, coverageName, file, node);
	}
	const $increment = (() => {
		const d = new Dictionary();
		d.branch = function(bid, eid, coverageName, data, file, node) {
			if(arguments.length < 6) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
			}
			if(bid === void 0 || bid === null) {
				throw new TypeError("'bid' is not nullable");
			}
			if(eid === void 0 || eid === null) {
				throw new TypeError("'eid' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $location((() => {
				const d = new Dictionary();
				d.kind = NodeKind.UnaryExpression;
				d.operator = (() => {
					const d = new Dictionary();
					d.kind = UnaryOperatorKind.IncrementPostfix;
					return d;
				})();
				d.argument = (() => {
					const d = new Dictionary();
					d.kind = NodeKind.MemberExpression;
					d.modifiers = [(() => {
						const d = new Dictionary();
						d.kind = ModifierKind.Computed;
						return d;
					})()];
					d.object = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.MemberExpression;
						d.modifiers = [(() => {
							const d = new Dictionary();
							d.kind = ModifierKind.Computed;
							return d;
						})()];
						d.object = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.MemberExpression;
							d.modifiers = [];
							d.object = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.MemberExpression;
								d.modifiers = [(() => {
									const d = new Dictionary();
									d.kind = ModifierKind.Computed;
									return d;
								})()];
								d.object = (() => {
									const d = new Dictionary();
									d.kind = NodeKind.Identifier;
									d.name = coverageName;
									return d;
								})();
								d.property = (() => {
									const d = new Dictionary();
									d.kind = NodeKind.Literal;
									d.value = node.reducePath(file);
									return d;
								})();
								return d;
							})();
							d.property = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.Identifier;
								d.name = "b";
								return d;
							})();
							return d;
						})();
						d.property = (() => {
							const d = new Dictionary();
							d.kind = NodeKind.NumericExpression;
							d.value = bid;
							return d;
						})();
						return d;
					})();
					d.property = (() => {
						const d = new Dictionary();
						d.kind = NodeKind.NumericExpression;
						d.value = eid;
						return d;
					})();
					return d;
				})();
				d.attributes = [];
				return d;
			})(), data);
		};
		return d;
	})();
	function $location() {
		if((arguments.length === 2 && Type.isNumber(arguments[1])) || arguments.length === 3) {
			let __ks_i = -1;
			let data = arguments[++__ks_i];
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			let lineStart = arguments[++__ks_i];
			if(lineStart === void 0 || lineStart === null) {
				throw new TypeError("'lineStart' is not nullable");
			}
			else if(!Type.isNumber(lineStart)) {
				throw new TypeError("'lineStart' is not of type 'Number'");
			}
			let lineEnd;
			if(arguments.length > 2 && (lineEnd = arguments[++__ks_i]) !== void 0 && lineEnd !== null) {
				if(!Type.isNumber(lineEnd)) {
					throw new TypeError("'lineEnd' is not of type 'Number'");
				}
			}
			else {
				lineEnd = lineStart;
			}
			data.start = (() => {
				const d = new Dictionary();
				d.line = lineStart;
				return d;
			})();
			data.end = (() => {
				const d = new Dictionary();
				d.line = lineEnd;
				return d;
			})();
			return data;
		}
		else if(arguments.length === 2) {
			let __ks_i = -1;
			let data = arguments[++__ks_i];
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			let location = arguments[++__ks_i];
			if(location === void 0 || location === null) {
				throw new TypeError("'location' is not nullable");
			}
			else if(!Type.isDictionary(location)) {
				throw new TypeError("'location' is not of type 'Dictionary'");
			}
			data.start = (() => {
				const d = new Dictionary();
				d.line = location.start.line;
				return d;
			})();
			data.end = (() => {
				const d = new Dictionary();
				d.line = location.end.line;
				return d;
			})();
			return data;
		}
		else {
			throw new SyntaxError("Wrong number of arguments");
		}
	};
	function $sequence(init, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(init === void 0 || init === null) {
			throw new TypeError("'init' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(Helper.valueOf(data.kind) === NodeKind.SequenceExpression.value) {
			let expressions = data.expressions;
			data.expressions = [init];
			for(let __ks_0 = 0, __ks_1 = expressions.length, expression; __ks_0 < __ks_1; ++__ks_0) {
				expression = expressions[__ks_0];
				data.expressions.push($compile.expression(expression, coverage, coverageName, file, node));
			}
			return data;
		}
		else {
			return (() => {
				const d = new Dictionary();
				d.kind = NodeKind.SequenceExpression;
				d.expressions = [init, $compile.expression(data, coverage, coverageName, file, node)];
				return d;
			})();
		}
	}
	const $statements = (() => {
		const d = new Dictionary();
		d[NodeKind.BreakStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ClassDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let members = data.members;
			data.members = [];
			for(let __ks_0 = 0, __ks_1 = members.length, member; __ks_0 < __ks_1; ++__ks_0) {
				member = members[__ks_0];
				let __ks_2 = member.kind.valueOf();
				if(__ks_2 === NodeKind.FieldDeclaration.value) {
					if(Type.isValue(member.defaultValue)) {
						member.defaultValue = $compile.expression(member.defaultValue, coverage, coverageName, file, node);
					}
					data.members.push(member);
				}
				else if(__ks_2 === NodeKind.MethodDeclaration.value) {
					if(Type.isValue(data.extends) && (member.name.name === "constructor") && !Type.isValue(member.body)) {
						data.members.push($constructor(members, member, coverage, coverageName, file, node));
					}
					else {
						data.members.push($statements[NodeKind.FunctionDeclaration](member, coverage, coverageName, file, node));
					}
				}
				else if(__ks_2 === NodeKind.MacroDeclaration.value) {
					data.members.push(member);
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + member.kind + "\"", file, member.start.line);
				}
			}
			return data;
		};
		d[NodeKind.ContinueStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.DestroyStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.DiscloseDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.DoUntilStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.DoWhileStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.EnumDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ExportDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.declarations = Helper.mapArray(data.declarations, function(declaration) {
				return $compile.compile(declaration, coverage, coverageName, file, node);
			});
			return data;
		};
		d[NodeKind.ExportExclusionSpecifier] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ExportDeclarationSpecifier] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.declaration = $compile.compile(data.declaration, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.ExternDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ExternOrRequireDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ForFromStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.from = $compile.expression(data.from, coverage, coverageName, file, node);
			if(Type.isValue(data.til)) {
				data.til = $compile.expression(data.til, coverage, coverageName, file, node);
			}
			else {
				data.to = $compile.expression(data.to, coverage, coverageName, file, node);
			}
			if(Type.isValue(data.by)) {
				data.by = $compile.expression(data.by, coverage, coverageName, file, node);
			}
			if(Type.isValue(data.when)) {
				data.body = $if(data.when, data.body, coverage, coverageName, file, node);
				delete data.when;
			}
			else {
				data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.ForInStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.when)) {
				data.body = $if(data.when, data.body, coverage, coverageName, file, node);
				delete data.when;
			}
			else {
				data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.ForOfStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.when)) {
				data.body = $if(data.when, data.body, coverage, coverageName, file, node);
				delete data.when;
			}
			else {
				data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.FunctionDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $function(data, coverage, coverageName, file, node);
		};
		d[NodeKind.IfStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
			let loc = (() => {
				const d = new Dictionary();
				d.start = (() => {
					const d = new Dictionary();
					d.line = data.start.line;
					d.column = Operator.subtraction(data.start.column, 1);
					return d;
				})();
				d.end = (() => {
					const d = new Dictionary();
					d.line = data.start.line;
					d.column = Operator.subtraction(data.start.column, 1);
					return d;
				})();
				return d;
			})();
			coverage.branchMap.push((() => {
				const d = new Dictionary();
				d.type = "if";
				d.line = data.start.line;
				d.locations = [loc, loc];
				return d;
			})());
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenTrue = $block($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, loc, file, node);
			if(Type.isValue(data.whenFalse)) {
				data.whenFalse = $block($increment.branch(bid, 1, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, loc, file, node);
			}
			return data;
		};
		d[NodeKind.ImplementDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let properties = data.properties;
			data.properties = [];
			for(let __ks_0 = 0, __ks_1 = properties.length, property; __ks_0 < __ks_1; ++__ks_0) {
				property = properties[__ks_0];
				let __ks_2 = property.kind.valueOf();
				if(__ks_2 === NodeKind.FieldDeclaration.value) {
					if(Type.isValue(property.defaultValue)) {
						property.defaultValue = $compile.expression(property.defaultValue, coverage, coverageName, file, node);
					}
					data.properties.push(property);
				}
				else if(__ks_2 === NodeKind.MethodDeclaration.value) {
					data.properties.push($statements[NodeKind.FunctionDeclaration](property, coverage, coverageName, file, node));
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + property.kind + "\"", file, property.start.line);
				}
			}
			return data;
		};
		d[NodeKind.ImportDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.IncludeDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.MacroDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.NamespaceDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.statements = $compile.statements(data.statements, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.RequireDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.RequireOrExternDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.RequireOrImportDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.ReturnStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.value)) {
				data.value = $compile.expression(data.value, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.SwitchStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
			const branch = (() => {
				const d = new Dictionary();
				d.type = "switch";
				d.line = data.start.line;
				d.locations = [];
				return d;
			})();
			coverage.branchMap.push(branch);
			data.expression = $compile.expression(data.expression, coverage, coverageName, file, node);
			let loc = null;
			for(let index = 0, __ks_0 = data.clauses.length, clause; index < __ks_0; ++index) {
				clause = data.clauses[index];
				loc = (() => {
					const d = new Dictionary();
					d.start = (() => {
						const d = new Dictionary();
						d.line = clause.start.line;
						d.column = Operator.subtraction(clause.start.column, 1);
						return d;
					})();
					d.end = (() => {
						const d = new Dictionary();
						d.line = clause.end.line;
						d.column = Operator.subtraction(clause.end.column, 1);
						return d;
					})();
					return d;
				})();
				clause.body = $block($increment.branch(bid, index, coverageName, clause.body, file, node), clause.body, coverage, coverageName, loc, file, node);
				branch.locations.push(loc);
			}
			return data;
		};
		d[NodeKind.ThrowStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.value = $compile.expression(data.value, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.TryStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.TypeAliasDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		};
		d[NodeKind.UnlessStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = Operator.addOrConcat(coverage.branchMap.length, 1);
			let loc = (() => {
				const d = new Dictionary();
				d.start = (() => {
					const d = new Dictionary();
					d.line = data.start.line;
					d.column = Operator.subtraction(data.start.column, 1);
					return d;
				})();
				d.end = (() => {
					const d = new Dictionary();
					d.line = data.start.line;
					d.column = Operator.subtraction(data.start.column, 1);
					return d;
				})();
				return d;
			})();
			coverage.branchMap.push((() => {
				const d = new Dictionary();
				d.type = "if";
				d.line = data.start.line;
				d.locations = [loc, loc];
				return d;
			})());
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenFalse = $block($increment.branch(bid, 0, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, loc, file, node);
			return data;
		};
		d[NodeKind.UntilStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		};
		d[NodeKind.VariableDeclaration] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.init)) {
				data.init = $compile.expression(data.init, coverage, coverageName, file, node);
			}
			return data;
		};
		d[NodeKind.WhileStatement] = function(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		};
		return d;
	})();
	class CoverageCompiler extends Compiler {
		__ks_init_1() {
			this._instrument = false;
		}
		__ks_init() {
			Compiler.prototype.__ks_init.call(this);
			CoverageCompiler.prototype.__ks_init_1.call(this);
		}
		__ks_cons(args) {
			Compiler.prototype.__ks_cons.call(this, args);
		}
		__ks_func_instrument_0(coverageName) {
			if(coverageName === void 0 || coverageName === null) {
				coverageName = "__ks_coverage";
			}
			this._coverageName = coverageName;
			this._instrument = true;
			return this;
		}
		instrument() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return CoverageCompiler.prototype.__ks_func_instrument_0.apply(this, arguments);
			}
			else if(Compiler.prototype.instrument) {
				return Compiler.prototype.instrument.apply(this, arguments);
			}
			throw new SyntaxError("Wrong number of arguments");
		}
		__ks_func_compile_0(data = null) {
			if(this._instrument) {
				this._module = new CoverageModule(Type.isValue(data) ? data : this.readFile(), this._coverageName, this, this._file);
			}
			else {
				this._module = new Module(Type.isValue(data) ? data : this.readFile(), this, this._file);
			}
			this._module.compile();
			this._fragments = this._module.toFragments();
			return this;
		}
		compile() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return CoverageCompiler.prototype.__ks_func_compile_0.apply(this, arguments);
			}
			return Compiler.prototype.compile.apply(this, arguments);
		}
	}
	class CoverageModule extends Module {
		__ks_init_1() {
			this._addCoverageVariable = true;
			this._coverages = [];
			this.excludeFile = function(file) {
				if(arguments.length < 1) {
					throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
				}
				if(file === void 0 || file === null) {
					throw new TypeError("'file' is not nullable");
				}
				return false;
			};
			this.reducePath = function(path) {
				if(arguments.length < 1) {
					throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
				}
				if(path === void 0 || path === null) {
					throw new TypeError("'path' is not nullable");
				}
				return path;
			};
		}
		__ks_init() {
			Module.prototype.__ks_init.call(this);
			CoverageModule.prototype.__ks_init_1.call(this);
		}
		__ks_cons_0(data, coverageName, compiler, file) {
			if(arguments.length < 4) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(compiler === void 0 || compiler === null) {
				throw new TypeError("'compiler' is not nullable");
			}
			else if(!Type.isClassInstance(compiler, Compiler)) {
				throw new TypeError("'compiler' is not of type 'Compiler'");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			this._coverageName = coverageName;
			if(Type.isFunction(compiler._options.excludeFile)) {
				this.excludeFile = compiler._options.excludeFile;
			}
			if(Type.isFunction(compiler._options.reducePath)) {
				this.reducePath = compiler._options.reducePath;
			}
			Module.prototype.__ks_cons.call(this, [data, compiler, file]);
		}
		__ks_cons(args) {
			if(args.length === 4) {
				CoverageModule.prototype.__ks_cons_0.apply(this, args);
			}
			else {
				throw new SyntaxError("Wrong number of arguments");
			}
		}
		__ks_func_parse_0(data, file) {
			if(arguments.length < 2) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(this.excludeFile(file) === true) {
				data = super.parse(data, file);
			}
			else {
				let coverage;
				this._coverages.push(coverage = (() => {
					const d = new Dictionary();
					d.path = this.reducePath(file);
					d.statementMap = [];
					d.branchMap = [];
					d.fnMap = [];
					return d;
				})());
				data = super.parse(data, file);
				data.body = $compile.statements(data.body, coverage, this._coverageName, file, this);
				if(this._addCoverageVariable) {
					data.body.unshift($location((() => {
						const d = new Dictionary();
						d.kind = NodeKind.ExternDeclaration;
						d.declarations = [(() => {
							const d = new Dictionary();
							d.kind = NodeKind.VariableDeclarator;
							d.modifiers = [];
							d.name = (() => {
								const d = new Dictionary();
								d.kind = NodeKind.Identifier;
								d.name = this._coverageName;
								return d;
							})();
							return d;
						})()];
						d.attributes = [];
						return d;
					})(), 1));
					this._addCoverageVariable = false;
				}
			}
			return data;
		}
		parse() {
			if(arguments.length === 2) {
				return CoverageModule.prototype.__ks_func_parse_0.apply(this, arguments);
			}
			return Module.prototype.parse.apply(this, arguments);
		}
		__ks_func_toFragments_0() {
			const header = new FragmentBuilder(0);
			header.line("var " + this._coverageName + " = (function(_export) {\n\treturn typeof _export." + this._coverageName + " === 'undefined' ? _export." + this._coverageName + " = {} : _export." + this._coverageName + ";\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this)");
			for(let __ks_0 = 0, __ks_1 = this._coverages.length, coverage; __ks_0 < __ks_1; ++__ks_0) {
				coverage = this._coverages[__ks_0];
				this.toCoverageFragments(header, coverage);
			}
			return header.toArray().concat(super.toFragments());
		}
		toFragments() {
			if(arguments.length === 0) {
				return CoverageModule.prototype.__ks_func_toFragments_0.apply(this);
			}
			return Module.prototype.toFragments.apply(this, arguments);
		}
		__ks_func_toCoverageFragments_0(fragments, coverage) {
			if(arguments.length < 2) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(fragments === void 0 || fragments === null) {
				throw new TypeError("'fragments' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			const line = fragments.newLine();
			line.code("if(!" + this._coverageName + "[\"" + coverage.path + "\"]) {\n");
			line.code("\t" + this._coverageName + "[\"" + coverage.path + "\"] = {");
			line.code("\"path\":\"" + coverage.path + "\",");
			line.code("\"s\":{");
			for(let i = 1, __ks_0 = coverage.statementMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":0");
			}
			line.code("},");
			line.code("\"b\":{");
			for(let i = 1, __ks_0 = coverage.branchMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":[");
				for(let j = 0, __ks_1 = coverage.branchMap[i - 1].locations.length; j < __ks_1; ++j) {
					if(j !== 0) {
						line.code(",");
					}
					line.code("0");
				}
				line.code("]");
			}
			line.code("},");
			line.code("\"f\":{");
			for(let i = 1, __ks_0 = coverage.fnMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":0");
			}
			line.code("},");
			line.code("\"statementMap\":{");
			for(let i = 0, __ks_0 = coverage.statementMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.statementMap[i]));
			}
			line.code("},");
			line.code("\"branchMap\":{");
			for(let i = 0, __ks_0 = coverage.branchMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.branchMap[i]));
			}
			line.code("},");
			line.code("\"fnMap\":{");
			for(let i = 0, __ks_0 = coverage.fnMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.fnMap[i]));
			}
			line.code("}");
			line.code("};\n");
			line.code("}");
			line.done();
		}
		toCoverageFragments() {
			if(arguments.length === 2) {
				return CoverageModule.prototype.__ks_func_toCoverageFragments_0.apply(this, arguments);
			}
			else if(Module.prototype.toCoverageFragments) {
				return Module.prototype.toCoverageFragments.apply(this, arguments);
			}
			throw new SyntaxError("Wrong number of arguments");
		}
	}
	return {
		Compiler: CoverageCompiler,
		extensions: extensions,
		getBinaryPath: getBinaryPath,
		getHashPath: getHashPath,
		isUpToDate: isUpToDate
	};
};