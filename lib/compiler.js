// Generated by kaoscript 0.9.0
require("kaoscript/register");
var {Helper, Type} = require("@kaoscript/runtime");
module.exports = function() {
	var {Exception, IOException, NotImplementedException, NotSupportedException, ReferenceException, SyntaxException, TypeException, Module, Compiler, compileFile, getBinaryPath, getHashPath, getMetadataPath, isUpToDate, extensions, AssignmentOperatorKind, BinaryOperatorKind, MacroElementKind, ModifierKind, NodeKind, ReificationKind, ScopeKind, UnaryOperatorKind, FragmentBuilder} = require("kaoscript")();
	function $block(init, data, coverage, coverageName, location, file, node) {
		if(arguments.length < 7) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 7)");
		}
		if(init === void 0 || init === null) {
			throw new TypeError("'init' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(location === void 0 || location === null) {
			throw new TypeError("'location' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(data.kind === NodeKind.Block) {
			data.statements = [].concat($location(init, location), $compile.statements(data.statements, coverage, coverageName, file, node));
			return data;
		}
		else {
			return $location({
				kind: NodeKind.Block,
				statements: [].concat($location(init, location), $compile.statements([data], coverage, coverageName, file, node))
			}, location);
		}
	}
	function $body(data, location) {
		if(arguments.length < 2) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(data === void 0) {
			data = null;
		}
		if(location === void 0 || location === null) {
			throw new TypeError("'location' is not nullable");
		}
		if(data === null) {
			return $location({
				kind: NodeKind.Block,
				statements: []
			}, location);
		}
		else if(data.kind === NodeKind.Block) {
			return data;
		}
		else {
			return $location({
				kind: NodeKind.Block,
				statements: [{
					kind: NodeKind.ReturnStatement,
					value: data,
					start: data.start,
					end: data.end
				}]
			}, location);
		}
	}
	const $compile = {
		compile(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue($statements[data.kind])) {
				return $statements[data.kind](data, coverage, coverageName, file, node);
			}
			else if(Type.isValue($expressions[data.kind])) {
				return $expressions[data.kind](data, coverage, coverageName, file, node);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + data.kind + "\"", file, data.start.line);
			}
		},
		expression(data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue($expressions[data.kind])) {
				return $expressions[data.kind](data, coverage, coverageName, file, node);
			}
			else {
				throw new NotImplementedException("Not supported kind \"" + data.kind + "\"", file, data.start.line);
			}
		},
		statements(statements, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(statements === void 0 || statements === null) {
				throw new TypeError("'statements' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			const result = [];
			for(let __ks_0 = 0, __ks_1 = statements.length, statement; __ks_0 < __ks_1; ++__ks_0) {
				statement = statements[__ks_0];
				let sid = coverage.statementMap.length + 1;
				coverage.statementMap.push({
					start: {
						line: statement.start.line,
						column: statement.start.column - 1
					},
					end: {
						line: statement.end.line,
						column: statement.end.column - 1
					}
				});
				result.push($location({
					kind: NodeKind.UnaryExpression,
					operator: {
						kind: UnaryOperatorKind.IncrementPostfix
					},
					argument: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.MemberExpression,
							object: {
								kind: NodeKind.MemberExpression,
								object: {
									kind: NodeKind.Identifier,
									name: coverageName
								},
								property: {
									kind: NodeKind.Literal,
									value: node.reducePath(file)
								},
								computed: true,
								nullable: false
							},
							property: {
								kind: NodeKind.Identifier,
								name: "s"
							},
							computed: false,
							nullable: false
						},
						property: {
							kind: NodeKind.NumericExpression,
							value: sid
						},
						computed: true,
						nullable: false
					},
					attributes: []
				}, statement));
				if(Type.isValue($statements[statement.kind])) {
					result.push($statements[statement.kind](statement, coverage, coverageName, file, node));
				}
				else if(Type.isValue($expressions[statement.kind])) {
					result.push($expressions[statement.kind](statement, coverage, coverageName, file, node));
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + statement.kind + "\"", file, statement.start.line);
				}
			}
			return result;
		}
	};
	function $constructor(members, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(members === void 0 || members === null) {
			throw new TypeError("'members' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		let fid = coverage.fnMap.length + 1;
		coverage.fnMap.push({
			name: data.name.name,
			line: data.start.line,
			loc: {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.end.line,
					column: data.end.column - 1
				}
			}
		});
		const fields = {};
		for(let __ks_0 = 0, __ks_1 = members.length, member; __ks_0 < __ks_1; ++__ks_0) {
			member = members[__ks_0];
			if(member.kind === NodeKind.FieldDeclaration) {
				fields[member.name.name] = true;
				if(member.name.name[0] === "_") {
					fields[member.name.name.substr(1)] = true;
				}
			}
		}
		data.body = $location({
			kind: NodeKind.Block,
			statements: [$location({
				kind: NodeKind.CallExpression,
				scope: {
					kind: ScopeKind.This
				},
				callee: {
					kind: NodeKind.Identifier,
					name: "super",
					start: data.start,
					end: data.end
				},
				arguments: [],
				nullable: false
			}, data), $location({
				kind: NodeKind.UnaryExpression,
				operator: {
					kind: UnaryOperatorKind.IncrementPostfix
				},
				argument: {
					kind: NodeKind.MemberExpression,
					object: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.MemberExpression,
							object: {
								kind: NodeKind.Identifier,
								name: coverageName
							},
							property: {
								kind: NodeKind.Literal,
								value: node.reducePath(file)
							},
							computed: true,
							nullable: false
						},
						property: {
							kind: NodeKind.Identifier,
							name: "f"
						},
						computed: false,
						nullable: false
					},
					property: {
						kind: NodeKind.NumericExpression,
						value: fid
					},
					computed: true,
					nullable: false
				},
				attributes: []
			}, data)]
		}, data);
		return data;
	}
	const $expressions = {
		[NodeKind.ArrayComprehension](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ArrayExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.values = Helper.mapArray(data.values, function(value) {
				return $compile.expression(value, coverage, coverageName, file, node);
			});
			return data;
		},
		[NodeKind.ArrayRange](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.BinaryExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if((data.operator.kind === BinaryOperatorKind.And) || (data.operator.kind === BinaryOperatorKind.Or)) {
				let bid = coverage.branchMap.length + 1;
				coverage.branchMap.push({
					type: "binary-expr",
					line: data.start.line,
					locations: [{
						start: {
							line: data.left.start.line,
							column: data.left.start.column - 1
						},
						end: {
							line: data.left.end.line,
							column: data.left.end.column - 1
						}
					}, {
						start: {
							line: data.right.start.line,
							column: data.right.start.column - 1
						},
						end: {
							line: data.right.end.line,
							column: data.right.end.column - 1
						}
					}]
				});
				data.left = $sequence($increment.branch(bid, 0, coverageName, data.left, file, node), data.left, coverage, coverageName, file, node);
				data.right = $sequence($increment.branch(bid, 1, coverageName, data.right, file, node), data.right, coverage, coverageName, file, node);
			}
			else if(data.operator.kind === BinaryOperatorKind.Assignment) {
				data.right = $compile.expression(data.right, coverage, coverageName, file, node);
			}
			else {
				data.left = $compile.expression(data.left, coverage, coverageName, file, node);
				data.right = $compile.expression(data.right, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.CallExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.callee = $compile.expression(data.callee, coverage, coverageName, file, node);
			data.arguments = Helper.mapArray(data.arguments, function(argument) {
				return $compile.expression(argument, coverage, coverageName, file, node);
			});
			return data;
		},
		[NodeKind.CallMacroExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ComparisonExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ConditionalExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = coverage.branchMap.length + 1;
			coverage.branchMap.push({
				type: "cond-expr",
				line: data.start.line,
				locations: [{
					start: {
						line: data.whenTrue.start.line,
						column: data.whenTrue.start.column - 1
					},
					end: {
						line: data.whenTrue.end.line,
						column: data.whenTrue.end.column - 1
					}
				}, {
					start: {
						line: data.whenFalse.start.line,
						column: data.whenFalse.start.column - 1
					},
					end: {
						line: data.whenFalse.end.line,
						column: data.whenFalse.end.column - 1
					}
				}]
			});
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, file, node);
			data.whenFalse = $sequence($increment.branch(bid, 1, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.CreateExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.class = $compile.expression(data.class, coverage, coverageName, file, node);
			data.arguments = Helper.mapArray(data.arguments, function(argument) {
				return $compile.expression(argument, coverage, coverageName, file, node);
			});
			return data;
		},
		[NodeKind.CurryExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.callee = $compile.expression(data.callee, coverage, coverageName, file, node);
			if(data.scope.kind === ScopeKind.Argument) {
				data.scope.value = $compile.expression(data.scope.value, coverage, coverageName, file, node);
			}
			data.arguments = Helper.mapArray(data.arguments, function(argument) {
				return $compile.expression(argument, coverage, coverageName, file, node);
			});
			return data;
		},
		[NodeKind.EnumExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ExportNamedSpecifier](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.FunctionExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $function(data, coverage, coverageName, file, node);
		},
		[NodeKind.IfExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = coverage.branchMap.length + 1;
			if(Type.isValue(data.whenFalse)) {
				coverage.branchMap.push({
					type: "cond-expr",
					line: data.start.line,
					locations: [{
						start: {
							line: data.whenTrue.start.line,
							column: data.whenTrue.start.column - 1
						},
						end: {
							line: data.whenTrue.end.line,
							column: data.whenTrue.end.column - 1
						}
					}, {
						start: {
							line: data.whenFalse.start.line,
							column: data.whenFalse.start.column - 1
						},
						end: {
							line: data.whenFalse.end.line,
							column: data.whenFalse.end.column - 1
						}
					}]
				});
				data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
				data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, file, node);
				data.whenFalse = $sequence($increment.branch(bid, 1, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, file, node);
			}
			else {
				coverage.branchMap.push({
					type: "cond-expr",
					line: data.start.line,
					locations: [{
						start: {
							line: data.start.line,
							column: data.start.column - 1
						},
						end: {
							line: data.start.line,
							column: data.start.column - 1
						}
					}, {
						start: {
							line: data.start.line,
							column: data.start.column - 1
						},
						end: {
							line: data.start.line,
							column: data.start.column - 1
						}
					}]
				});
				data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
				data.whenTrue = $sequence($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.MemberExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.object = $compile.expression(data.object, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.NumericExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.Identifier](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.LambdaExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $function(data, coverage, coverageName, file, node);
		},
		[NodeKind.Literal](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ObjectExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let properties = data.properties;
			data.properties = [];
			for(let __ks_0 = 0, __ks_1 = properties.length, property; __ks_0 < __ks_1; ++__ks_0) {
				property = properties[__ks_0];
				data.properties.push($compile.expression(property, coverage, coverageName, file, node));
			}
			return data;
		},
		[NodeKind.ObjectMember](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.value = $compile.expression(data.value, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.PolyadicExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if((data.operator.kind === BinaryOperatorKind.And) || (data.operator.kind === BinaryOperatorKind.Or)) {
				let bid = coverage.branchMap.length + 1;
				let branch;
				coverage.branchMap.push(branch = {
					type: "binary-expr",
					line: data.start.line,
					locations: []
				});
				let operands = data.operands;
				data.operands = [];
				for(let index = 0, __ks_0 = operands.length, operand; index < __ks_0; ++index) {
					operand = operands[index];
					branch.locations.push({
						start: {
							line: operand.start.line,
							column: operand.start.column - 1
						},
						end: {
							line: operand.end.line,
							column: operand.end.column - 1
						}
					});
					data.operands.push($sequence($increment.branch(bid, index, coverageName, operand, file, node), operand, coverage, coverageName, file, node));
				}
			}
			else {
				data.operands = Helper.mapArray(data.operands, function(operand) {
					return $compile.expression(operand, coverage, coverageName, file, node);
				});
			}
			return data;
		},
		[NodeKind.RegularExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ShorthandProperty](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.TemplateExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.elements = Helper.mapArray(data.elements, function(element) {
				return $compile.expression(element, coverage, coverageName, file, node);
			});
			return data;
		},
		[NodeKind.ThisExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.TypeReference](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.UnaryExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.argument = $compile.expression(data.argument, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.UnlessExpression](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = coverage.branchMap.length + 1;
			coverage.branchMap.push({
				type: "cond-expr",
				line: data.start.line,
				locations: [{
					start: {
						line: data.start.line,
						column: data.start.column - 1
					},
					end: {
						line: data.start.line,
						column: data.start.column - 1
					}
				}, {
					start: {
						line: data.start.line,
						column: data.start.column - 1
					},
					end: {
						line: data.start.line,
						column: data.start.column - 1
					}
				}]
			});
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenFalse = $sequence($increment.branch(bid, 0, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.VariableDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.init = $compile.expression(data.init, coverage, coverageName, file, node);
			return data;
		}
	};
	function $function(data, coverage, coverageName, file, node) {
		if(arguments.length < 5) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		let fid = coverage.fnMap.length + 1;
		coverage.fnMap.push({
			name: (Type.isValue(data.name) && Type.isValue(data.name.name)) ? data.name.name : "(anonymous_" + fid + ")",
			line: data.start.line,
			loc: {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.end.line,
					column: data.end.column - 1
				}
			}
		});
		data.body = $block({
			kind: NodeKind.UnaryExpression,
			operator: {
				kind: UnaryOperatorKind.IncrementPostfix
			},
			argument: {
				kind: NodeKind.MemberExpression,
				object: {
					kind: NodeKind.MemberExpression,
					object: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.Identifier,
							name: coverageName
						},
						property: {
							kind: NodeKind.Literal,
							value: node.reducePath(file)
						},
						computed: true,
						nullable: false
					},
					property: {
						kind: NodeKind.Identifier,
						name: "f"
					},
					computed: false,
					nullable: false
				},
				property: {
					kind: NodeKind.NumericExpression,
					value: fid
				},
				computed: true,
				nullable: false
			},
			attributes: []
		}, $body(data.body, data), coverage, coverageName, data, file, node);
		return data;
	}
	function $if(condition, whenTrue, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(condition === void 0 || condition === null) {
			throw new TypeError("'condition' is not nullable");
		}
		if(whenTrue === void 0 || whenTrue === null) {
			throw new TypeError("'whenTrue' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		let data = {
			kind: NodeKind.IfStatement,
			condition,
			start: condition.start,
			end: whenTrue.end
		};
		if(whenTrue.kind === NodeKind.Block) {
			data.whenTrue = whenTrue;
		}
		else {
			data.whenTrue = {
				kind: NodeKind.Block,
				statements: [whenTrue]
			};
		}
		return $statements[NodeKind.IfStatement](data, coverage, coverageName, file, node);
	}
	const $increment = {
		branch(bid, eid, coverageName, data, file, node) {
			if(arguments.length < 6) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
			}
			if(bid === void 0 || bid === null) {
				throw new TypeError("'bid' is not nullable");
			}
			if(eid === void 0 || eid === null) {
				throw new TypeError("'eid' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $location({
				kind: NodeKind.UnaryExpression,
				operator: {
					kind: UnaryOperatorKind.IncrementPostfix
				},
				argument: {
					kind: NodeKind.MemberExpression,
					object: {
						kind: NodeKind.MemberExpression,
						object: {
							kind: NodeKind.MemberExpression,
							object: {
								kind: NodeKind.MemberExpression,
								object: {
									kind: NodeKind.Identifier,
									name: coverageName
								},
								property: {
									kind: NodeKind.Literal,
									value: node.reducePath(file)
								},
								computed: true,
								nullable: false
							},
							property: {
								kind: NodeKind.Identifier,
								name: "b"
							},
							computed: false,
							nullable: false
						},
						property: {
							kind: NodeKind.NumericExpression,
							value: bid
						},
						computed: true,
						nullable: false
					},
					property: {
						kind: NodeKind.NumericExpression,
						value: eid
					},
					computed: true,
					nullable: false
				},
				attributes: []
			}, data);
		}
	};
	function $location() {
		if(arguments.length === 2 && Type.isObject(arguments[1])) {
			let __ks_i = -1;
			let data = arguments[++__ks_i];
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			let location = arguments[++__ks_i];
			if(location === void 0 || location === null) {
				throw new TypeError("'location' is not nullable");
			}
			else if(!Type.isObject(location)) {
				throw new TypeError("'location' is not of type 'Object'");
			}
			data.start = {
				line: location.start.line
			};
			data.end = {
				line: location.end.line
			};
			return data;
		}
		else if(arguments.length === 2 || arguments.length === 3) {
			let __ks_i = -1;
			let data = arguments[++__ks_i];
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			let lineStart = arguments[++__ks_i];
			if(lineStart === void 0 || lineStart === null) {
				throw new TypeError("'lineStart' is not nullable");
			}
			else if(!Type.isNumber(lineStart)) {
				throw new TypeError("'lineStart' is not of type 'Number'");
			}
			let lineEnd;
			if(arguments.length > 2 && (lineEnd = arguments[++__ks_i]) !== void 0 && lineEnd !== null) {
				if(!Type.isNumber(lineEnd)) {
					throw new TypeError("'lineEnd' is not of type 'Number'");
				}
			}
			else {
				lineEnd = lineStart;
			}
			data.start = {
				line: lineStart
			};
			data.end = {
				line: lineEnd
			};
			return data;
		}
		else {
			throw new SyntaxError("Wrong number of arguments");
		}
	};
	function $sequence(init, data, coverage, coverageName, file, node) {
		if(arguments.length < 6) {
			throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 6)");
		}
		if(init === void 0 || init === null) {
			throw new TypeError("'init' is not nullable");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		if(coverage === void 0 || coverage === null) {
			throw new TypeError("'coverage' is not nullable");
		}
		if(coverageName === void 0 || coverageName === null) {
			throw new TypeError("'coverageName' is not nullable");
		}
		if(file === void 0 || file === null) {
			throw new TypeError("'file' is not nullable");
		}
		if(node === void 0 || node === null) {
			throw new TypeError("'node' is not nullable");
		}
		if(data.kind === NodeKind.SequenceExpression) {
			let expressions = data.expressions;
			data.expressions = [init];
			for(let __ks_0 = 0, __ks_1 = expressions.length, expression; __ks_0 < __ks_1; ++__ks_0) {
				expression = expressions[__ks_0];
				data.expressions.push($compile.expression(expression, coverage, coverageName, file, node));
			}
			return data;
		}
		else {
			return {
				kind: NodeKind.SequenceExpression,
				expressions: [init, $compile.expression(data, coverage, coverageName, file, node)]
			};
		}
	}
	const $statements = {
		[NodeKind.BreakStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ClassDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let members = data.members;
			data.members = [];
			for(let __ks_0 = 0, __ks_1 = members.length, member; __ks_0 < __ks_1; ++__ks_0) {
				member = members[__ks_0];
				let __ks_2 = member.kind;
				if(__ks_2 === NodeKind.FieldDeclaration) {
					if(Type.isValue(member.defaultValue)) {
						member.defaultValue = $compile.expression(member.defaultValue, coverage, coverageName, file, node);
					}
					data.members.push(member);
				}
				else if(__ks_2 === NodeKind.MethodDeclaration) {
					if(Type.isValue(data.extends) && (member.name.name === "constructor") && !Type.isValue(member.body)) {
						data.members.push($constructor(members, member, coverage, coverageName, file, node));
					}
					else {
						data.members.push($statements[NodeKind.FunctionDeclaration](member, coverage, coverageName, file, node));
					}
				}
				else if(__ks_2 === NodeKind.MacroDeclaration) {
					data.members.push(member);
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + member.kind + "\"", file, member.start.line);
				}
			}
			return data;
		},
		[NodeKind.ContinueStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.DestroyStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.DiscloseDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.DoUntilStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.DoWhileStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.EnumDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ExportDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.declarations = Helper.mapArray(data.declarations, function(declaration) {
				return $compile.compile(declaration, coverage, coverageName, file, node);
			});
			return data;
		},
		[NodeKind.ExportDeclarationSpecifier](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.declaration = $compile.compile(data.declaration, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.ExternDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ExternOrRequireDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ForFromStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.from = $compile.expression(data.from, coverage, coverageName, file, node);
			if(Type.isValue(data.til)) {
				data.til = $compile.expression(data.til, coverage, coverageName, file, node);
			}
			else {
				data.to = $compile.expression(data.to, coverage, coverageName, file, node);
			}
			if(Type.isValue(data.by)) {
				data.by = $compile.expression(data.by, coverage, coverageName, file, node);
			}
			if(Type.isValue(data.when)) {
				data.body = $if(data.when, data.body, coverage, coverageName, file, node);
				delete data.when;
			}
			else {
				data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.ForInStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.when)) {
				data.body = $if(data.when, data.body, coverage, coverageName, file, node);
				delete data.when;
			}
			else {
				data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.ForOfStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.when)) {
				data.body = $if(data.when, data.body, coverage, coverageName, file, node);
				delete data.when;
			}
			else {
				data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.FunctionDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return $function(data, coverage, coverageName, file, node);
		},
		[NodeKind.IfStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = coverage.branchMap.length + 1;
			let loc = {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.start.line,
					column: data.start.column - 1
				}
			};
			coverage.branchMap.push({
				type: "if",
				line: data.start.line,
				locations: [loc, loc]
			});
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenTrue = $block($increment.branch(bid, 0, coverageName, data.whenTrue, file, node), data.whenTrue, coverage, coverageName, loc, file, node);
			if(Type.isValue(data.whenFalse)) {
				data.whenFalse = $block($increment.branch(bid, 1, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, loc, file, node);
			}
			return data;
		},
		[NodeKind.ImplementDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let properties = data.properties;
			data.properties = [];
			for(let __ks_0 = 0, __ks_1 = properties.length, property; __ks_0 < __ks_1; ++__ks_0) {
				property = properties[__ks_0];
				let __ks_2 = property.kind;
				if(__ks_2 === NodeKind.FieldDeclaration) {
					if(Type.isValue(property.defaultValue)) {
						property.defaultValue = $compile.expression(property.defaultValue, coverage, coverageName, file, node);
					}
					data.properties.push(property);
				}
				else if(__ks_2 === NodeKind.MethodDeclaration) {
					data.properties.push($statements[NodeKind.FunctionDeclaration](property, coverage, coverageName, file, node));
				}
				else {
					throw new NotImplementedException("Not supported kind \"" + property.kind + "\"", file, property.start.line);
				}
			}
			return data;
		},
		[NodeKind.ImportDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.IncludeDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.MacroDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.NamespaceDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.statements = $compile.statements(data.statements, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.RequireDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.RequireOrExternDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.RequireOrImportDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.ReturnStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.value)) {
				data.value = $compile.expression(data.value, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.SwitchStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = coverage.branchMap.length + 1;
			const branch = {
				type: "switch",
				line: data.start.line,
				locations: []
			};
			coverage.branchMap.push(branch);
			data.expression = $compile.expression(data.expression, coverage, coverageName, file, node);
			let loc;
			for(let index = 0, __ks_0 = data.clauses.length, clause; index < __ks_0; ++index) {
				clause = data.clauses[index];
				loc = {
					start: {
						line: clause.start.line,
						column: clause.start.column - 1
					},
					end: {
						line: clause.end.line,
						column: clause.end.column - 1
					}
				};
				clause.body = $block($increment.branch(bid, index, coverageName, clause.body, file, node), clause.body, coverage, coverageName, loc, file, node);
				branch.locations.push(loc);
			}
			return data;
		},
		[NodeKind.ThrowStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.value = $compile.expression(data.value, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.TryStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.TypeAliasDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			return data;
		},
		[NodeKind.UnlessStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			let bid = coverage.branchMap.length + 1;
			let loc = {
				start: {
					line: data.start.line,
					column: data.start.column - 1
				},
				end: {
					line: data.start.line,
					column: data.start.column - 1
				}
			};
			coverage.branchMap.push({
				type: "if",
				line: data.start.line,
				locations: [loc, loc]
			});
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.whenFalse = $block($increment.branch(bid, 0, coverageName, data.whenFalse, file, node), data.whenFalse, coverage, coverageName, loc, file, node);
			return data;
		},
		[NodeKind.UntilStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		},
		[NodeKind.VariableDeclaration](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(Type.isValue(data.init)) {
				data.init = $compile.expression(data.init, coverage, coverageName, file, node);
			}
			return data;
		},
		[NodeKind.WhileStatement](data, coverage, coverageName, file, node) {
			if(arguments.length < 5) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			data.condition = $compile.expression(data.condition, coverage, coverageName, file, node);
			data.body.statements = $compile.statements(data.body.statements, coverage, coverageName, file, node);
			return data;
		}
	};
	class CoverageCompiler extends Compiler {
		__ks_init_1() {
			this._instrument = false;
		}
		__ks_init() {
			Compiler.prototype.__ks_init.call(this);
			CoverageCompiler.prototype.__ks_init_1.call(this);
		}
		__ks_cons(args) {
			Compiler.prototype.__ks_cons.call(this, args);
		}
		__ks_func_instrument_0(coverageName) {
			if(coverageName === void 0 || coverageName === null) {
				coverageName = "__ks_coverage";
			}
			this._coverageName = coverageName;
			this._instrument = true;
			return this;
		}
		instrument() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return CoverageCompiler.prototype.__ks_func_instrument_0.apply(this, arguments);
			}
			else if(Compiler.prototype.instrument) {
				return Compiler.prototype.instrument.apply(this, arguments);
			}
			throw new SyntaxError("Wrong number of arguments");
		}
		__ks_func_compile_0(data = null) {
			if(this._instrument) {
				this._module = new CoverageModule(Type.isValue(data) ? data : this.readFile(), this._coverageName, this, this._file);
			}
			else {
				this._module = new Module(Type.isValue(data) ? data : this.readFile(), this, this._file);
			}
			this._module.compile();
			this._fragments = this._module.toFragments();
			return this;
		}
		compile() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return CoverageCompiler.prototype.__ks_func_compile_0.apply(this, arguments);
			}
			return Compiler.prototype.compile.apply(this, arguments);
		}
	}
	class CoverageModule extends Module {
		__ks_init_1() {
			this._addCoverageVariable = true;
			this._coverages = [];
			this.excludeFile = function(file) {
				if(arguments.length < 1) {
					throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
				}
				if(file === void 0 || file === null) {
					throw new TypeError("'file' is not nullable");
				}
				return false;
			};
			this.reducePath = function(path) {
				if(arguments.length < 1) {
					throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 1)");
				}
				if(path === void 0 || path === null) {
					throw new TypeError("'path' is not nullable");
				}
				return path;
			};
		}
		__ks_init() {
			Module.prototype.__ks_init.call(this);
			CoverageModule.prototype.__ks_init_1.call(this);
		}
		__ks_cons_0(data, coverageName, compiler, file) {
			if(arguments.length < 4) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(coverageName === void 0 || coverageName === null) {
				throw new TypeError("'coverageName' is not nullable");
			}
			if(compiler === void 0 || compiler === null) {
				throw new TypeError("'compiler' is not nullable");
			}
			else if(!Type.is(compiler, Compiler)) {
				throw new TypeError("'compiler' is not of type 'Compiler'");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			this._coverageName = coverageName;
			if(Type.isFunction(compiler._options.excludeFile)) {
				this.excludeFile = compiler._options.excludeFile;
			}
			if(Type.isFunction(compiler._options.reducePath)) {
				this.reducePath = compiler._options.reducePath;
			}
			Module.prototype.__ks_cons.call(this, [data, compiler, file]);
		}
		__ks_cons(args) {
			if(args.length === 4) {
				CoverageModule.prototype.__ks_cons_0.apply(this, args);
			}
			else {
				throw new SyntaxError("Wrong number of arguments");
			}
		}
		__ks_func_parse_0(data, file) {
			if(arguments.length < 2) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			if(file === void 0 || file === null) {
				throw new TypeError("'file' is not nullable");
			}
			if(this.excludeFile(file)) {
				data = super.parse(data, file);
			}
			else {
				let coverage;
				this._coverages.push(coverage = {
					path: this.reducePath(file),
					statementMap: [],
					branchMap: [],
					fnMap: []
				});
				data = super.parse(data, file);
				data.body = $compile.statements(data.body, coverage, this._coverageName, file, this);
				if(this._addCoverageVariable) {
					data.body.unshift($location({
						kind: NodeKind.ExternDeclaration,
						declarations: [{
							kind: NodeKind.VariableDeclarator,
							name: {
								kind: NodeKind.Identifier,
								name: this._coverageName
							}
						}],
						attributes: []
					}, 1));
					this._addCoverageVariable = false;
				}
			}
			return data;
		}
		parse() {
			if(arguments.length === 2) {
				return CoverageModule.prototype.__ks_func_parse_0.apply(this, arguments);
			}
			return Module.prototype.parse.apply(this, arguments);
		}
		__ks_func_toFragments_0() {
			const header = new FragmentBuilder(0);
			header.line("var " + this._coverageName + " = (function(_export) {\n\treturn typeof _export." + this._coverageName + " === 'undefined' ? _export." + this._coverageName + " = {} : _export." + this._coverageName + ";\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this)");
			for(let __ks_0 = 0, __ks_1 = this._coverages.length, coverage; __ks_0 < __ks_1; ++__ks_0) {
				coverage = this._coverages[__ks_0];
				this.toCoverageFragments(header, coverage);
			}
			return header.toArray().concat(super.toFragments());
		}
		toFragments() {
			if(arguments.length === 0) {
				return CoverageModule.prototype.__ks_func_toFragments_0.apply(this);
			}
			return Module.prototype.toFragments.apply(this, arguments);
		}
		__ks_func_toCoverageFragments_0(fragments, coverage) {
			if(arguments.length < 2) {
				throw new SyntaxError("Wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(fragments === void 0 || fragments === null) {
				throw new TypeError("'fragments' is not nullable");
			}
			if(coverage === void 0 || coverage === null) {
				throw new TypeError("'coverage' is not nullable");
			}
			const line = fragments.newLine();
			line.code("if(!" + this._coverageName + "[\"" + coverage.path + "\"]) {\n");
			line.code("\t" + this._coverageName + "[\"" + coverage.path + "\"] = {");
			line.code("\"path\":\"" + coverage.path + "\",");
			line.code("\"s\":{");
			for(let i = 1, __ks_0 = coverage.statementMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":0");
			}
			line.code("},");
			line.code("\"b\":{");
			for(let i = 1, __ks_0 = coverage.branchMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":[");
				for(let j = 0, __ks_1 = coverage.branchMap[i - 1].locations.length; j < __ks_1; ++j) {
					if(j !== 0) {
						line.code(",");
					}
					line.code("0");
				}
				line.code("]");
			}
			line.code("},");
			line.code("\"f\":{");
			for(let i = 1, __ks_0 = coverage.fnMap.length; i <= __ks_0; ++i) {
				if(i > 1) {
					line.code(",");
				}
				line.code("\"" + i + "\":0");
			}
			line.code("},");
			line.code("\"statementMap\":{");
			for(let i = 0, __ks_0 = coverage.statementMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.statementMap[i]));
			}
			line.code("},");
			line.code("\"branchMap\":{");
			for(let i = 0, __ks_0 = coverage.branchMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.branchMap[i]));
			}
			line.code("},");
			line.code("\"fnMap\":{");
			for(let i = 0, __ks_0 = coverage.fnMap.length; i < __ks_0; ++i) {
				if(i > 0) {
					line.code(",");
				}
				line.code("\"" + (i + 1) + "\":" + JSON.stringify(coverage.fnMap[i]));
			}
			line.code("}");
			line.code("};\n");
			line.code("}");
			line.done();
		}
		toCoverageFragments() {
			if(arguments.length === 2) {
				return CoverageModule.prototype.__ks_func_toCoverageFragments_0.apply(this, arguments);
			}
			else if(Module.prototype.toCoverageFragments) {
				return Module.prototype.toCoverageFragments.apply(this, arguments);
			}
			throw new SyntaxError("Wrong number of arguments");
		}
	}
	return {
		Compiler: CoverageCompiler,
		extensions: extensions,
		getBinaryPath: getBinaryPath,
		getHashPath: getHashPath,
		isUpToDate: isUpToDate
	};
};